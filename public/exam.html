<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Quiz Contest - Examination Portal">
    <meta name="robots" content="noindex, nofollow">
    <title>Examination | Quiz Contest</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="alternate icon" href="/favicon.ico">

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap"
        rel="stylesheet">

    <!-- Styles -->
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/3d-theme.css">
    <link rel="stylesheet" href="/css/responsive.css">

    <style>
        /* Exam page specific styles */

        /* 3D Background Logo */
        .background-logo {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) perspective(1000px) rotateY(-5deg) rotateX(5deg);
            width: 60vw;
            max-width: 600px;
            opacity: 0.08;
            z-index: 0;
            pointer-events: none;
            animation: float3d 8s ease-in-out infinite;
            filter: drop-shadow(0 0 60px rgba(167, 139, 250, 0.25));
        }

        .background-logo img {
            width: 100%;
            height: auto;
        }

        @keyframes float3d {

            0%,
            100% {
                transform: translate(-50%, -50%) perspective(1000px) rotateY(-5deg) rotateX(5deg) translateZ(0);
            }

            25% {
                transform: translate(-50%, -50%) perspective(1000px) rotateY(3deg) rotateX(-3deg) translateZ(20px);
            }

            50% {
                transform: translate(-50%, -50%) perspective(1000px) rotateY(5deg) rotateX(5deg) translateZ(40px);
            }

            75% {
                transform: translate(-50%, -50%) perspective(1000px) rotateY(-3deg) rotateX(-5deg) translateZ(20px);
            }
        }

        /* Torch flame glow effect */
        .background-logo::after {
            content: '';
            position: absolute;
            top: 20%;
            right: 25%;
            width: 80px;
            height: 120px;
            background: radial-gradient(ellipse at center, rgba(167, 139, 250, 0.25) 0%, rgba(147, 197, 253, 0.15) 40%, transparent 70%);
            border-radius: 50% 50% 50% 50%;
            filter: blur(20px);
            animation: flameGlow 2s ease-in-out infinite alternate;
        }

        @keyframes flameGlow {
            0% {
                opacity: 0.5;
                transform: scale(1);
            }

            100% {
                opacity: 0.8;
                transform: scale(1.1);
            }
        }

        body {
            background: transparent !important;
            color: hsl(230, 25%, 18%);
        }

        .exam-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
        }

        .exam-header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--space-md) var(--space-lg);
            background: var(--surface-glass);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
        }

        .exam-info {
            display: flex;
            align-items: center;
            gap: var(--space-lg);
        }

        .exam-round-badge {
            padding: var(--space-xs) var(--space-md);
            background: var(--primary-glow);
            color: var(--primary-light);
            border-radius: var(--radius-full);
            font-weight: 600;
            font-size: 0.85rem;
        }

        .participant-info {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .exam-main {
            padding-top: 80px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .exam-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--space-xl);
        }

        .exam-question-container {
            width: 100%;
            max-width: 800px;
        }

        .exam-progress {
            margin-bottom: var(--space-xl);
        }

        .exam-progress-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: var(--space-sm);
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .exam-actions {
            display: flex;
            justify-content: flex-end;
            gap: var(--space-md);
            margin-top: var(--space-xl);
        }

        /* Warning overlay */
        .warning-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: hsla(230, 20%, 92%, 0.92);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            text-align: center;
            padding: var(--space-xl);
        }

        .warning-overlay.hidden {
            display: none;
        }

        .warning-icon-large {
            width: 80px;
            height: 80px;
            background: var(--danger);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            margin-bottom: var(--space-xl);
            animation: pulse 1s infinite;
        }

        .warning-title {
            font-size: 2rem;
            color: var(--danger);
            margin-bottom: var(--space-md);
        }

        .warning-text {
            font-size: 1.1rem;
            color: var(--text-secondary);
            max-width: 500px;
            margin-bottom: var(--space-xl);
        }

        .warning-count {
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* Screen states */
        .screen {
            display: none;
        }

        .screen.active {
            display: flex;
        }

        /* Success checkmark animation */
        .completion-icon {
            animation: successPulse 2s ease-in-out infinite;
        }

        @keyframes successPulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.1);
                opacity: 0.9;
            }
        }
    </style>
</head>

<body>
    <!-- 3D Background Logo - VSBEC Kanal 2026 -->
    <div class="background-logo">
        <svg viewBox="0 0 400 200" xmlns="http://www.w3.org/2000/svg">
            <!-- Torch Handle -->
            <defs>
                <linearGradient id="flameGradient" x1="0%" y1="100%" x2="0%" y2="0%">
                    <stop offset="0%" style="stop-color:#ff6b35;stop-opacity:1" />
                    <stop offset="50%" style="stop-color:#ffa500;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#ffff00;stop-opacity:1" />
                </linearGradient>
                <filter id="glow">
                    <feGaussianBlur stdDeviation="3" result="coloredBlur" />
                    <feMerge>
                        <feMergeNode in="coloredBlur" />
                        <feMergeNode in="SourceGraphic" />
                    </feMerge>
                </filter>
            </defs>

            <!-- VSBEC Text -->
            <text x="80" y="70" font-family="Inter, Arial, sans-serif" font-size="28" font-weight="600"
                fill="rgba(100,110,180,0.6)" letter-spacing="8">VSBEC</text>

            <!-- Kanal Text (Large) -->
            <text x="50" y="130" font-family="Inter, Arial, sans-serif" font-size="60" font-weight="700"
                fill="rgba(100,110,180,0.6)" letter-spacing="2">Kanal</text>

            <!-- Torch -->
            <g transform="translate(240, 40)">
                <!-- Handle -->
                <rect x="15" y="60" width="12" height="50" rx="3" fill="#8B4513" />
                <rect x="10" y="55" width="22" height="12" rx="2" fill="#CD853F" />

                <!-- Flame -->
                <path d="M21 55 Q21 30, 10 20 Q15 35, 21 40 Q27 35, 32 20 Q21 30, 21 55" fill="url(#flameGradient)"
                    filter="url(#glow)">
                    <animate attributeName="d" values="M21 55 Q21 30, 10 20 Q15 35, 21 40 Q27 35, 32 20 Q21 30, 21 55;
                                M21 55 Q21 25, 8 15 Q16 32, 21 38 Q26 32, 34 15 Q21 25, 21 55;
                                M21 55 Q21 30, 10 20 Q15 35, 21 40 Q27 35, 32 20 Q21 30, 21 55" dur="1s"
                        repeatCount="indefinite" />
                </path>

                <!-- Inner flame -->
                <path d="M21 55 Q21 40, 16 35 Q19 42, 21 45 Q23 42, 26 35 Q21 40, 21 55" fill="#fff8dc" opacity="0.8">
                    <animate attributeName="d" values="M21 55 Q21 40, 16 35 Q19 42, 21 45 Q23 42, 26 35 Q21 40, 21 55;
                                M21 55 Q21 38, 14 32 Q18 40, 21 43 Q24 40, 28 32 Q21 38, 21 55;
                                M21 55 Q21 40, 16 35 Q19 42, 21 45 Q23 42, 26 35 Q21 40, 21 55" dur="0.8s"
                        repeatCount="indefinite" />
                </path>
            </g>

            <!-- 2026 Text -->
            <text x="220" y="170" font-family="Inter, Arial, sans-serif" font-size="36" font-weight="600"
                fill="rgba(100,110,180,0.5)" letter-spacing="4">2026</text>
        </svg>
    </div>

    <!-- 3D Background Logo - QUIZ CONTEST -->
    <div class="background-logo logo-cc">
        <svg viewBox="0 0 500 300" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <linearGradient id="textGradient2" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:#ff9900;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#ff5500;stop-opacity:1" />
                </linearGradient>
                <filter id="ccGlow2">
                    <feGaussianBlur stdDeviation="4" result="coloredBlur" />
                    <feMerge>
                        <feMergeNode in="coloredBlur" />
                        <feMergeNode in="SourceGraphic" />
                    </feMerge>
                </filter>
            </defs>

            <!-- Mountain Icon -->
            <path d="M250 40 L290 90 L210 90 Z" fill="#fff" opacity="0.9" transform="translate(0, -10)" />
            <path d="M250 40 L270 90 L230 90 Z" fill="#eee" opacity="0.5" transform="translate(0, -10)" />

            <!-- CURRENT Text -->
            <text x="250" y="140" font-family="Arial Black, Impact, sans-serif" font-size="70" font-weight="900"
                font-style="italic" fill="#fff" text-anchor="middle" letter-spacing="2"
                transform="rotate(-5, 250, 150)">CURRENT</text>

            <!-- CONQUEST Text -->
            <text x="250" y="210" font-family="Arial Black, Impact, sans-serif" font-size="85" font-weight="900"
                font-style="italic" fill="url(#textGradient2)" text-anchor="middle" letter-spacing="1"
                filter="url(#ccGlow2)" transform="rotate(-5, 250, 150)">CONQUEST</text>

            <!-- Lightning Bolt -->
            <path d="M280 180 L240 240 L270 240 L230 300 L260 250 L230 250 L270 180 Z" fill="#ffcc00" stroke="#fff"
                stroke-width="2" transform="rotate(-15, 250, 240) translate(20, -20)" />

            <!-- Decor lines -->
            <path d="M50 160 L450 100" stroke="#ff9900" stroke-width="3" stroke-opacity="0.6" stroke-linecap="round" />
            <path d="M50 240 L450 180" stroke="#ff9900" stroke-width="3" stroke-opacity="0.6" stroke-linecap="round" />
        </svg>
    </div>

    <!-- 3D Canvas Container -->
    <div id="canvas-container"></div>

    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="logo">
            <div class="logo-icon">QC</div>
            <span class="title-gradient">Quiz Contest</span>
        </div>
        <div class="spinner spinner-lg"></div>
    </div>

    <!-- Warning Overlay (Tab Switch) -->
    <div class="warning-overlay hidden" id="warningOverlay">
        <div class="warning-icon-large">âš ï¸</div>
        <h1 class="warning-title">Warning!</h1>
        <p class="warning-text" id="warningText">
            You switched tabs or windows. This is your first warning.
            Another violation will result in automatic submission.
        </p>
        <p class="warning-count" id="warningCount">Violations: 1/2</p>
        <button class="btn btn-danger btn-lg" id="dismissWarning">Continue Exam</button>
    </div>

    <!-- Waiting Screen -->
    <div class="screen waiting-screen" id="waitingScreen">
        <div class="waiting-cartoon" id="waitingCartoon">
            <!-- Cute animated cartoon owl waiting -->
            <svg viewBox="0 0 200 200" width="160" height="160" xmlns="http://www.w3.org/2000/svg">
                <!-- Floating stars -->
                <g class="cartoon-stars">
                    <text x="30" y="30" font-size="18" fill="#ffd700" opacity="0.8">
                        â­
                        <animate attributeName="opacity" values="0.3;1;0.3" dur="2s" repeatCount="indefinite" />
                        <animateTransform attributeName="transform" type="translate" values="0,0;5,-5;0,0" dur="3s"
                            repeatCount="indefinite" />
                    </text>
                    <text x="160" y="50" font-size="14" fill="#ffd700" opacity="0.6">
                        âœ¨
                        <animate attributeName="opacity" values="0.5;1;0.5" dur="1.5s" repeatCount="indefinite" />
                        <animateTransform attributeName="transform" type="translate" values="0,0;-3,-8;0,0" dur="2.5s"
                            repeatCount="indefinite" />
                    </text>
                    <text x="20" y="150" font-size="12" fill="#ffd700" opacity="0.7">
                        âœ¨
                        <animate attributeName="opacity" values="1;0.3;1" dur="2.2s" repeatCount="indefinite" />
                    </text>
                </g>
                <!-- Owl body -->
                <g transform="translate(100,105)">
                    <animateTransform attributeName="transform" type="translate" values="100,105;100,98;100,105"
                        dur="2s" repeatCount="indefinite" />
                    <!-- Body -->
                    <ellipse cx="0" cy="20" rx="42" ry="45" fill="#8B6914" />
                    <ellipse cx="0" cy="25" rx="32" ry="35" fill="#C4A55A" />
                    <!-- Belly pattern -->
                    <ellipse cx="0" cy="35" rx="20" ry="22" fill="#DFC87C" opacity="0.7" />
                    <!-- Eyes -->
                    <circle cx="-16" cy="-5" r="16" fill="white" stroke="#5C4A10" stroke-width="2" />
                    <circle cx="16" cy="-5" r="16" fill="white" stroke="#5C4A10" stroke-width="2" />
                    <!-- Pupils (blinking) -->
                    <circle cx="-14" cy="-3" r="8" fill="#2C1810">
                        <animate attributeName="ry" values="8;1;8" dur="3s" repeatCount="indefinite"
                            keyTimes="0;0.03;1" />
                    </circle>
                    <circle cx="18" cy="-3" r="8" fill="#2C1810">
                        <animate attributeName="ry" values="8;1;8" dur="3s" repeatCount="indefinite"
                            keyTimes="0;0.03;1" />
                    </circle>
                    <!-- Eye shine -->
                    <circle cx="-11" cy="-7" r="3" fill="white" opacity="0.8" />
                    <circle cx="21" cy="-7" r="3" fill="white" opacity="0.8" />
                    <!-- Beak -->
                    <path d="M-5 8 L0 16 L5 8" fill="#FF8C00" stroke="#CC7000" stroke-width="1" />
                    <!-- Eyebrows/Horns -->
                    <path d="M-30 -18 Q-25 -30, -15 -20" fill="#5C4A10" stroke="none" />
                    <path d="M30 -18 Q25 -30, 15 -20" fill="#5C4A10" stroke="none" />
                    <!-- Wings -->
                    <path d="M-42 10 Q-55 0, -45 -15 Q-40 5, -35 15" fill="#7A5C10" opacity="0.8">
                        <animateTransform attributeName="transform" type="rotate" values="0 -42 10;-8 -42 10;0 -42 10"
                            dur="2s" repeatCount="indefinite" />
                    </path>
                    <path d="M42 10 Q55 0, 45 -15 Q40 5, 35 15" fill="#7A5C10" opacity="0.8">
                        <animateTransform attributeName="transform" type="rotate" values="0 42 10;8 42 10;0 42 10"
                            dur="2s" repeatCount="indefinite" />
                    </path>
                    <!-- Feet -->
                    <path d="M-15 62 L-22 70 M-15 62 L-15 72 M-15 62 L-8 70" stroke="#FF8C00" stroke-width="3"
                        fill="none" stroke-linecap="round" />
                    <path d="M15 62 L8 70 M15 62 L15 72 M15 62 L22 70" stroke="#FF8C00" stroke-width="3" fill="none"
                        stroke-linecap="round" />
                </g>
                <!-- Zzz sleeping/waiting text -->
                <g opacity="0.6">
                    <text x="145" y="55" font-size="16" fill="#a0c4ff" font-weight="bold">z
                        <animate attributeName="opacity" values="0;1;0" dur="2s" repeatCount="indefinite" />
                        <animateTransform attributeName="transform" type="translate" values="0,0;8,-12" dur="2s"
                            repeatCount="indefinite" />
                    </text>
                    <text x="155" y="40" font-size="12" fill="#a0c4ff" font-weight="bold">z
                        <animate attributeName="opacity" values="0;1;0" dur="2s" repeatCount="indefinite"
                            begin="0.5s" />
                        <animateTransform attributeName="transform" type="translate" values="0,0;5,-10" dur="2s"
                            repeatCount="indefinite" begin="0.5s" />
                    </text>
                    <text x="162" y="28" font-size="10" fill="#a0c4ff" font-weight="bold">z
                        <animate attributeName="opacity" values="0;1;0" dur="2s" repeatCount="indefinite" begin="1s" />
                        <animateTransform attributeName="transform" type="translate" values="0,0;4,-8" dur="2s"
                            repeatCount="indefinite" begin="1s" />
                    </text>
                </g>
            </svg>
        </div>
        <h1 class="waiting-title" id="waitingTitle">Waiting for Round to Start</h1>
        <p class="waiting-message" id="waitingMessage">
            Please wait. The coordinator will start the round shortly.
            Do not close this window.
        </p>
        <div id="tokenDisplay" style="margin-top: var(--space-xl); color: var(--text-muted);">
            <p>Your Token: <span id="displayToken"
                    style="font-family: 'JetBrains Mono', monospace; font-size: 0.8rem;">-</span></p>
        </div>
    </div>

    <!-- Exam Screen -->
    <div class="screen" id="examScreen" style="flex-direction: column;">
        <header class="exam-header">
            <div class="exam-header-content">
                <div class="exam-info">
                    <span class="exam-round-badge" id="roundBadge">Round 1</span>
                </div>
                <div class="exam-timer" id="examTimer">
                    <span>â±ï¸</span>
                    <span id="timerDisplay">15:00</span>
                </div>
                <div class="participant-info"
                    style="display: flex; flex-direction: column; align-items: flex-end; line-height: 1.2;">
                    <span id="pNameDisplay" style="font-weight: 600; color: white;">Participant</span>
                    <span id="pCollegeDisplay" style="font-size: 0.75rem; color: var(--text-muted);">College</span>
                    <div style="font-size: 0.7rem; margin-top: 2px;">
                        <span>ğŸ”‘</span>
                        <span class="badge badge-neutral" id="headerToken"
                            style="font-family: 'JetBrains Mono', monospace; font-size: 0.7rem;">Token</span>
                    </div>
                </div>
            </div>
        </header>

        <main class="exam-main">
            <div class="exam-content">
                <div class="exam-question-container">
                    <!-- Progress -->
                    <div class="exam-progress">
                        <div class="exam-progress-info">
                            <span>Question <span id="currentQuestionNum">1</span> of <span
                                    id="totalQuestions">15</span></span>
                            <span><span id="answeredCount">0</span> answered</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill" style="width: 0%;"></div>
                        </div>
                    </div>

                    <!-- Question Card -->
                    <div class="question-card" id="questionCard">
                        <span class="question-number" id="questionLabel">Question 1</span>
                        <p class="question-text" id="questionText">Loading question...</p>

                        <div class="options-list" id="optionsList">
                            <!-- Options will be rendered here -->
                        </div>

                        <div class="exam-actions">
                            <button class="btn btn-primary btn-lg" id="nextBtn">
                                <span id="nextBtnText">Next Question</span>
                                <span>â†’</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Completion Screen -->
    <div class="screen completion-screen" id="completionScreen">
        <div class="completion-icon">âœ“</div>
        <h1 class="completion-title">Exam Submitted!</h1>
        <p class="completion-message" id="completionMessage">
            Your answers have been successfully submitted.
            Please wait for the results. Do not close this window.
        </p>
        <div id="submissionInfo"
            style="margin-top: var(--space-lg); padding: var(--space-lg) var(--space-xl); background: var(--surface-glass); backdrop-filter: blur(10px); border: 1px solid var(--border-color); border-radius: var(--radius-lg); text-align: center;">
            <p id="completionParticipantName"
                style="font-size: 1.3rem; font-weight: 700; color: var(--primary-light); margin-bottom: var(--space-sm);">
            </p>
            <p style="color: var(--text-secondary); font-size: 0.95rem;">
                Submitted at: <span id="submissionTime" style="font-weight: 600; color: var(--text-primary);">-</span>
            </p>
        </div>
    </div>

    <script>
        /**
         * Quiz Contest â€” Exam Page (V4 Architecture)
         *
         * ARCHITECTURE:
         *   â€¢ No login/registration â€” token generated on page load
         *   â€¢ attempt_token (UUID) stored in localStorage
         *   â€¢ All questions loaded in single API call
         *   â€¢ Answers stored in memory â€” no per-question API calls
         *   â€¢ Single bulk submission at end
         *   â€¢ Fully idempotent submission (duplicate = success)
         *   â€¢ NEVER shows "Failed to submit" â€” immediate success UI
         *   â€¢ Auto-retry on network failure
         *   â€¢ Checks submission status endpoint as final fallback
         */
        (function () {
            'use strict';

            // â”€â”€â”€ UUID Generator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            function generateUUID() {
                if (crypto.randomUUID) return crypto.randomUUID();
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                    const r = Math.random() * 16 | 0;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            }

            // â”€â”€â”€ Attempt Token Management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Generate or retrieve existing attempt_token from localStorage
            function getOrCreateAttemptToken() {
                const STORAGE_KEY = 'qc_attempt_token';
                let token = localStorage.getItem(STORAGE_KEY);
                if (!token) {
                    token = generateUUID();
                    localStorage.setItem(STORAGE_KEY, token);
                }
                return token;
            }

            // Clear token (called after round ends)
            function clearAttemptToken() {
                localStorage.removeItem('qc_attempt_token');
                localStorage.removeItem('qc_submitted');
                localStorage.removeItem('qc_round');
            }

            // â”€â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const attemptToken = getOrCreateAttemptToken();

            let state = {
                currentRound: 0,
                roundStatus: 'not_started',
                roundEndsAt: null,
                currentQuestionNum: 1,
                selectedOption: null,
                isSubmitting: false,
                isSubmitted: false,
                timerInterval: null,
                statusInterval: null,
                tabSwitchCount: 0,
                serverTimeOffset: 0,
                totalQuestions: 15,
                // BULK SUBMISSION: Store all answers in memory
                answers: {},  // { questionId: selectedOption }
                examStartTime: null
            };

            // Check if already submitted
            if (localStorage.getItem('qc_submitted') === 'true') {
                state.isSubmitted = true;
            }

            // â”€â”€â”€ DOM Elements â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const screens = {
                loading: document.getElementById('loadingScreen'),
                waiting: document.getElementById('waitingScreen'),
                exam: document.getElementById('examScreen'),
                completion: document.getElementById('completionScreen')
            };

            const elements = {
                warningOverlay: document.getElementById('warningOverlay'),
                warningText: document.getElementById('warningText'),
                warningCount: document.getElementById('warningCount'),
                dismissWarning: document.getElementById('dismissWarning'),
                waitingTitle: document.getElementById('waitingTitle'),
                waitingMessage: document.getElementById('waitingMessage'),
                displayToken: document.getElementById('displayToken'),
                roundBadge: document.getElementById('roundBadge'),
                timerDisplay: document.getElementById('timerDisplay'),
                examTimer: document.getElementById('examTimer'),
                headerToken: document.getElementById('headerToken'),
                currentQuestionNum: document.getElementById('currentQuestionNum'),
                totalQuestions: document.getElementById('totalQuestions'),
                answeredCount: document.getElementById('answeredCount'),
                progressFill: document.getElementById('progressFill'),
                questionLabel: document.getElementById('questionLabel'),
                questionText: document.getElementById('questionText'),
                optionsList: document.getElementById('optionsList'),
                nextBtn: document.getElementById('nextBtn'),
                nextBtnText: document.getElementById('nextBtnText'),
                completionMessage: document.getElementById('completionMessage'),
                submissionTime: document.getElementById('submissionTime')
            };

            // Display token
            elements.displayToken.textContent = attemptToken.substring(0, 8) + '...';
            elements.headerToken.textContent = attemptToken.substring(0, 8);

            // â”€â”€â”€ Display Participant Info â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const pName = localStorage.getItem('qc_p_name');
            const pCollege = localStorage.getItem('qc_p_college');

            if (pName) {
                document.getElementById('pNameDisplay').textContent = pName;
            }
            if (pCollege) {
                const phone = localStorage.getItem('qc_p_phone');
                document.getElementById('pCollegeDisplay').textContent = phone ? `${pCollege} â€¢ ${phone}` : pCollege;
            }

            // â”€â”€â”€ API Helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            async function api(endpoint, options = {}) {
                const response = await fetch(endpoint, {
                    ...options,
                    headers: {
                        'Content-Type': 'application/json',
                        ...options.headers
                    }
                });
                return response.json();
            }

            // â”€â”€â”€ Show specific screen â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            function showScreen(screenName) {
                Object.values(screens).forEach(screen => {
                    screen.classList.remove('active');
                    screen.style.display = 'none';
                });

                if (screens[screenName]) {
                    screens[screenName].classList.add('active');
                    screens[screenName].style.display = 'flex';
                }
            }

            // â”€â”€â”€ Sync server time â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            async function syncServerTime() {
                try {
                    const start = Date.now();
                    const result = await api('/api/server-time');
                    const end = Date.now();
                    const latency = (end - start) / 2;

                    if (result.success) {
                        const serverTime = new Date(result.serverTime).getTime();
                        state.serverTimeOffset = serverTime - Date.now() + latency;
                    }
                } catch (error) {
                    console.error('Time sync error:', error);
                }
            }

            function getServerTime() {
                return Date.now() + state.serverTimeOffset;
            }

            // â”€â”€â”€ Format time â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            function formatTime(seconds) {
                if (seconds < 0) seconds = 0;
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }

            // â”€â”€â”€ Update timer display â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            function updateTimer() {
                if (!state.roundEndsAt) return;

                const now = getServerTime();
                const endTime = new Date(state.roundEndsAt).getTime();
                const remaining = Math.max(0, Math.floor((endTime - now) / 1000));

                elements.timerDisplay.textContent = formatTime(remaining);

                // Timer warnings
                if (remaining <= 60) {
                    elements.examTimer.classList.add('danger');
                    elements.examTimer.classList.remove('warning');
                } else if (remaining <= 180) {
                    elements.examTimer.classList.add('warning');
                    elements.examTimer.classList.remove('danger');
                } else {
                    elements.examTimer.classList.remove('warning', 'danger');
                }

                // Auto-submit when time expires
                if (remaining <= 0 && !state.isSubmitting && !state.isSubmitted) {
                    clearInterval(state.timerInterval);
                    // Save current answer before auto-submit
                    if (state.currentQuestion?.questionId && state.selectedOption) {
                        state.answers[state.currentQuestion.questionId] = state.selectedOption;
                    }
                    submitExam('auto_timer');
                }
            }

            // â”€â”€â”€ Start timer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            function startTimer() {
                if (state.timerInterval) {
                    clearInterval(state.timerInterval);
                }
                updateTimer();
                state.timerInterval = setInterval(updateTimer, 1000);
            }

            // â”€â”€â”€ Check status â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            async function checkStatus() {
                try {
                    // If already submitted, show completion
                    if (state.isSubmitted) {
                        showScreen('completion');
                        stopStatusPolling();
                        return;
                    }

                    const result = await api('/api/exam/status');

                    if (!result.success) {
                        console.error('Status check failed');
                        return;
                    }

                    const data = result.data;
                    state.currentRound = data.currentRound;
                    state.roundStatus = data.roundStatus;
                    state.roundEndsAt = data.roundEndsAt;

                    // Handle different states
                    if (data.roundStatus === 'running' && data.eventActive) {
                        // Check if we already submitted for this round
                        const storedRound = localStorage.getItem('qc_round');
                        if (storedRound && parseInt(storedRound) !== data.currentRound) {
                            // New round â€” clear old data
                            clearAttemptToken();
                            location.reload();
                            return;
                        }

                        // Load questions and start exam
                        await startExam(data.currentRound);
                        stopStatusPolling();
                    } else if (data.roundStatus === 'completed') {
                        // Check if we have results
                        updateWaitingScreen(data);
                        showScreen('waiting');
                    } else {
                        // Waiting for round to start
                        updateWaitingScreen(data);
                        showScreen('waiting');
                    }

                } catch (error) {
                    console.error('Status check error:', error);
                }
            }

            // â”€â”€â”€ Update waiting screen â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            function updateWaitingScreen(data) {
                if (!data.eventActive) {
                    elements.waitingTitle.textContent = 'Event Not Active';
                    elements.waitingMessage.textContent =
                        'The examination event has not started yet. Please wait for the coordinator.';
                } else if (data.currentRound === 0) {
                    elements.waitingTitle.textContent = 'Event Starting Soon';
                    elements.waitingMessage.textContent =
                        'The event has been activated. Please wait for Round 1 to begin.';
                } else if (data.roundStatus === 'completed') {
                    elements.waitingTitle.textContent = `Round ${data.currentRound} Completed`;
                    elements.waitingMessage.textContent =
                        'Please wait while results are being processed.';
                } else {
                    elements.waitingTitle.textContent = `Waiting for Round ${data.currentRound || 1}`;
                    elements.waitingMessage.textContent =
                        'Please wait. The coordinator will start the round shortly.';
                }
            }

            // â”€â”€â”€ Status Polling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            function startStatusPolling() {
                if (state.statusInterval) {
                    clearInterval(state.statusInterval);
                }
                state.statusInterval = setInterval(checkStatus, 3000);
            }

            function stopStatusPolling() {
                if (state.statusInterval) {
                    clearInterval(state.statusInterval);
                    state.statusInterval = null;
                }
            }

            // â”€â”€â”€ All questions stored in memory â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            let allQuestions = [];

            // â”€â”€â”€ Start exam â€” Load ALL questions at once â”€â”€â”€â”€â”€â”€â”€â”€
            async function startExam(roundNumber) {
                try {
                    const result = await api('/api/exam/questions');

                    if (!result.success || !result.data.questions || result.data.questions.length === 0) {
                        console.error('Failed to load questions');
                        // Retry once
                        await new Promise(r => setTimeout(r, 1000));
                        const retry = await api('/api/exam/questions');
                        if (retry.success && retry.data.questions) {
                            allQuestions = retry.data.questions;
                        } else {
                            elements.waitingTitle.textContent = 'Loading Questions...';
                            elements.waitingMessage.textContent = 'Questions are being loaded. Please wait.';
                            showScreen('waiting');
                            startStatusPolling();
                            return;
                        }
                    } else {
                        allQuestions = result.data.questions;
                    }

                    state.totalQuestions = allQuestions.length;
                    state.roundEndsAt = result.data?.roundEndsAt;
                    state.currentRound = roundNumber;
                    state.examStartTime = Date.now();
                    localStorage.setItem('qc_round', roundNumber.toString());

                    // Update UI
                    elements.roundBadge.textContent = `Round ${roundNumber}`;
                    elements.totalQuestions.textContent = state.totalQuestions;

                    // Display first question
                    displayQuestion(1);
                    showScreen('exam');
                    startTimer();

                } catch (error) {
                    console.error('Start exam error:', error);
                    // Keep waiting
                    startStatusPolling();
                }
            }

            // â”€â”€â”€ Display question (INSTANT â€” no network call) â”€â”€â”€
            function displayQuestion(questionNumber) {
                const question = allQuestions.find(q => q.questionNumber === questionNumber);
                if (!question) {
                    if (allQuestions.length === 0) {
                        elements.questionText.textContent = 'Failed to load questions. Please refresh the page.';
                    }
                    return;
                }

                state.currentQuestion = question;
                state.currentQuestionNum = questionNumber;

                // Restore previously selected answer if any
                state.selectedOption = state.answers[question.questionId] || null;

                // Update UI instantly
                elements.currentQuestionNum.textContent = questionNumber;
                elements.questionLabel.textContent = `Question ${questionNumber}`;
                elements.questionText.textContent = question.questionText;
                elements.progressFill.style.width = `${((questionNumber - 1) / state.totalQuestions) * 100}%`;
                elements.answeredCount.textContent = Object.keys(state.answers).length;

                // Update button text
                if (questionNumber >= state.totalQuestions) {
                    elements.nextBtnText.textContent = 'Submit Exam';
                } else {
                    elements.nextBtnText.textContent = 'Next Question';
                }

                // Render options
                renderOptions(question.options, state.selectedOption);
            }

            // â”€â”€â”€ Render options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            function renderOptions(options, selectedOption) {
                elements.optionsList.innerHTML = '';

                const optionKeys = ['A', 'B', 'C', 'D'];

                optionKeys.forEach(key => {
                    const optionItem = document.createElement('div');
                    optionItem.className = 'option-item';

                    const isChecked = selectedOption === key;

                    optionItem.innerHTML = `
                        <input 
                            type="radio" 
                            id="option${key}" 
                            name="answer" 
                            value="${key}" 
                            class="option-input"
                            ${isChecked ? 'checked' : ''}
                        >
                        <label for="option${key}" class="option-label">
                            <span class="option-indicator">${key}</span>
                            <span class="option-text">${options[key]}</span>
                        </label>
                    `;

                    const input = optionItem.querySelector('input');
                    input.addEventListener('change', () => {
                        state.selectedOption = key;
                    });

                    elements.optionsList.appendChild(optionItem);
                });
            }

            // â”€â”€â”€ Submit answer and go to next (INSTANT) â”€â”€â”€â”€â”€â”€â”€â”€â”€
            function submitAnswer() {
                if (state.isSubmitting || state.isSubmitted) return;

                const currentNum = state.currentQuestionNum;
                const isLastQuestion = currentNum >= state.totalQuestions;
                const savedQuestionId = state.currentQuestion?.questionId;
                const savedOption = state.selectedOption;

                // Store answer in memory (no API call)
                if (savedQuestionId && savedOption) {
                    state.answers[savedQuestionId] = savedOption;
                }

                if (isLastQuestion) {
                    // Last question â€” submit ALL answers
                    elements.nextBtn.disabled = true;
                    submitExam('manual');
                } else {
                    // INSTANT: Display next question (pure DOM, no network)
                    displayQuestion(currentNum + 1);
                }
            }

            // â”€â”€â”€ Submit exam with ALL answers (BULK SUBMISSION) â”€
            let submitRetryCount = 0;
            const MAX_SUBMIT_RETRIES = 3;

            async function submitExam(submissionType = 'manual') {
                // Guard: only one submission at a time
                if (state.isSubmitting && submissionType === 'manual') return;
                if (state.isSubmitted) {
                    showScreen('completion');
                    return;
                }

                state.isSubmitting = true;
                elements.nextBtn.disabled = true;

                // Calculate time taken
                const timeTaken = state.examStartTime
                    ? Math.floor((Date.now() - state.examStartTime) / 1000)
                    : 0;

                try {
                    // Convert answers object to array format
                    const answersArray = Object.entries(state.answers).map(([questionId, selectedOption]) => ({
                        question_id: questionId,
                        selected_option: selectedOption
                    }));

                    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    // IMMEDIATELY show success UI
                    // This is the "No Failure Message" policy
                    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    state.isSubmitted = true;
                    localStorage.setItem('qc_submitted', 'true');
                    clearInterval(state.timerInterval);
                    showScreen('completion');

                    if (submissionType === 'auto_timer') {
                        elements.completionMessage.textContent =
                            'Time\'s up! Your answers have been automatically submitted.';
                    } else {
                        elements.completionMessage.textContent =
                            'Your answers have been successfully submitted. Please wait for the results.';
                    }
                    elements.submissionTime.textContent = new Date().toLocaleTimeString();

                    // Show participant name on completion screen
                    const participantName = localStorage.getItem('qc_p_name');
                    const nameEl = document.getElementById('completionParticipantName');
                    if (participantName && nameEl) {
                        nameEl.textContent = participantName;
                    }

                    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    // Send to backend (fire-and-forget with retry)
                    // UI already shows success â€” this is best-effort
                    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    const result = await api('/api/exam/submit', {
                        method: 'POST',
                        body: JSON.stringify({
                            attempt_token: attemptToken,
                            round_number: state.currentRound,
                            answers: answersArray,
                            time_taken_seconds: timeTaken
                        })
                    });

                    if (result.success) {
                        submitRetryCount = 0;
                        console.log('âœ… Submission confirmed by server');
                    } else {
                        throw new Error('Server returned non-success');
                    }

                } catch (error) {
                    console.error('Submit error (retrying):', error);
                    submitRetryCount++;

                    if (submitRetryCount < MAX_SUBMIT_RETRIES) {
                        // Retry in background â€” UI already shows success
                        setTimeout(() => retrySubmission(submissionType), 1000 * submitRetryCount);
                    } else {
                        // Check submission status as fallback
                        checkSubmissionStatus();
                    }
                } finally {
                    state.isSubmitting = false;
                }
            }

            // â”€â”€â”€ Retry submission in background â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            async function retrySubmission(submissionType) {
                try {
                    const timeTaken = state.examStartTime
                        ? Math.floor((Date.now() - state.examStartTime) / 1000)
                        : 0;

                    const answersArray = Object.entries(state.answers).map(([questionId, selectedOption]) => ({
                        question_id: questionId,
                        selected_option: selectedOption
                    }));

                    const result = await api('/api/exam/submit', {
                        method: 'POST',
                        body: JSON.stringify({
                            attempt_token: attemptToken,
                            round_number: state.currentRound,
                            answers: answersArray,
                            time_taken_seconds: timeTaken
                        })
                    });

                    if (result.success) {
                        submitRetryCount = 0;
                        console.log('âœ… Retry submission confirmed');
                    } else {
                        throw new Error('Retry non-success');
                    }
                } catch (error) {
                    submitRetryCount++;
                    if (submitRetryCount < MAX_SUBMIT_RETRIES) {
                        setTimeout(() => retrySubmission(submissionType), 1000 * submitRetryCount);
                    } else {
                        checkSubmissionStatus();
                    }
                }
            }

            // â”€â”€â”€ Check submission status (final fallback) â”€â”€â”€â”€â”€â”€â”€
            async function checkSubmissionStatus() {
                try {
                    const result = await api(`/api/exam/submission-status/${attemptToken}`);
                    if (result.submitted) {
                        console.log('âœ… Submission verified via status check');
                    } else {
                        console.warn('âš  Submission may not have been recorded. Retrying one last time.');
                        // One final retry
                        retrySubmission('fallback');
                    }
                } catch (error) {
                    console.error('Status check failed:', error);
                    // UI already shows success â€” don't panic
                }
            }

            // â”€â”€â”€ Handle tab switch/visibility change â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            function handleVisibilityChange() {
                if (document.hidden && screens.exam.classList.contains('active') && !state.isSubmitting && !state.isSubmitted) {
                    state.tabSwitchCount++;

                    // Save current answer
                    if (state.currentQuestion?.questionId && state.selectedOption) {
                        state.answers[state.currentQuestion.questionId] = state.selectedOption;
                    }

                    if (state.tabSwitchCount >= 2) {
                        // 2nd+ switch â†’ auto-submit
                        submitExam('auto_violation');
                    } else {
                        // 1st switch â†’ warning
                        elements.warningText.textContent =
                            'âš ï¸ CRITICAL WARNING: You switched tabs or windows during the exam. ' +
                            'This is your FIRST and ONLY warning. ' +
                            'If you switch again, your exam will be auto-submitted.';
                        elements.warningCount.textContent = `Violations: ${state.tabSwitchCount} / 2 (next = auto-submit)`;
                        elements.warningOverlay.classList.remove('hidden');
                    }
                }
            }

            // â”€â”€â”€ Handle page refresh attempt â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            function handleBeforeUnload(e) {
                if (screens.exam.classList.contains('active') && !state.isSubmitted) {
                    e.preventDefault();
                    e.returnValue = 'Your exam is in progress. Are you sure you want to leave?';
                    return e.returnValue;
                }
            }

            // â”€â”€â”€ Dismiss warning â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            function dismissWarning() {
                elements.warningOverlay.classList.add('hidden');
            }

            // â”€â”€â”€ Initialize â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            async function init() {
                await syncServerTime();

                // If already submitted, show completion immediately
                if (state.isSubmitted) {
                    showScreen('completion');
                    elements.completionMessage.textContent =
                        'Your answers have been submitted. Please wait for the results.';
                    return;
                }

                await checkStatus();
                startStatusPolling();

                // Event listeners
                elements.nextBtn.addEventListener('click', submitAnswer);
                elements.dismissWarning.addEventListener('click', dismissWarning);
                document.addEventListener('visibilitychange', handleVisibilityChange);
                window.addEventListener('beforeunload', handleBeforeUnload);

                // Prevent right-click context menu
                document.addEventListener('contextmenu', (e) => {
                    if (screens.exam.classList.contains('active')) {
                        e.preventDefault();
                    }
                });

                // Prevent keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (screens.exam.classList.contains('active')) {
                        if ((e.ctrlKey && ['c', 'v', 'a', 'u'].includes(e.key.toLowerCase())) ||
                            e.key === 'F12') {
                            e.preventDefault();
                        }
                    }
                });
            }

            init();
        })();
    </script>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        /**
         * White Glassmorphism 3D Background â€” Exam Page
         * Frosted Glass Platforms & Floating Pastel Sparkles
         */
        (function () {
            const container = document.getElementById('canvas-container');
            if (!container) return;

            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f2ff);
            scene.fog = new THREE.Fog(0xf0f2ff, 18, 65);

            const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 8, 22);
            camera.lookAt(0, 0, 0);

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            container.appendChild(renderer.domElement);

            // Soft Lighting
            const ambientLight = new THREE.AmbientLight(0xe8ecff, 0.9);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            const lavLight = new THREE.PointLight(0xc4b5fd, 1.0, 60);
            lavLight.position.set(-10, 8, -5);
            scene.add(lavLight);

            const peachLight = new THREE.PointLight(0xfbbf94, 0.6, 50);
            peachLight.position.set(8, 3, 8);
            scene.add(peachLight);

            // Pastel Glass Colors
            const colors = [0xc4b5fd, 0x93c5fd, 0x86efac, 0xfbbf94, 0xfca5a5];

            // Floating glass orbs
            const orbs = [];
            for (let i = 0; i < 10; i++) {
                const geo = new THREE.SphereGeometry(0.8 + Math.random() * 1.2, 32, 32);
                const mat = new THREE.MeshPhysicalMaterial({
                    color: colors[i % colors.length],
                    roughness: 0.1,
                    metalness: 0.02,
                    transmission: 0.92,
                    thickness: 2.5,
                    transparent: true,
                    opacity: 0.5,
                    clearcoat: 1.0,
                });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(
                    (Math.random() - 0.5) * 30,
                    (Math.random() - 0.5) * 15,
                    (Math.random() - 0.5) * 20
                );
                scene.add(mesh);
                orbs.push({
                    mesh,
                    speed: 0.002 + Math.random() * 0.004,
                    offset: Math.random() * Math.PI * 2,
                    radius: 8 + Math.random() * 12
                });
            }

            // Sparkle particles
            const sparkleGeo = new THREE.BufferGeometry();
            const sparkleCount = 350;
            const sparklePos = new Float32Array(sparkleCount * 3);
            for (let i = 0; i < sparkleCount * 3; i++) {
                sparklePos[i] = (Math.random() - 0.5) * 80;
            }
            sparkleGeo.setAttribute('position', new THREE.BufferAttribute(sparklePos, 3));
            const sparkleMat = new THREE.PointsMaterial({
                color: 0xa78bfa,
                size: 0.1,
                transparent: true,
                opacity: 0.35
            });
            const sparkles = new THREE.Points(sparkleGeo, sparkleMat);
            scene.add(sparkles);

            let time = 0;
            function animate() {
                requestAnimationFrame(animate);
                time += 0.008;

                orbs.forEach(orb => {
                    orb.mesh.position.x += Math.sin(time * orb.speed * 10 + orb.offset) * 0.02;
                    orb.mesh.position.y += Math.cos(time * 0.5 + orb.offset) * 0.01;
                    orb.mesh.rotation.y += 0.005;
                });

                sparkles.rotation.y = time * 0.015;

                camera.position.x = Math.sin(time * 0.08) * 2;
                camera.position.y = 8 + Math.cos(time * 0.08) * 1.5;
                camera.lookAt(0, 0, 0);

                renderer.render(scene, camera);
            }

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
        })();
    </script>

</body>

</html>