<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Quiz Conquest - Examination Portal">
    <meta name="robots" content="noindex, nofollow">
    <title>Examination | Quiz Conquest</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="alternate icon" href="/favicon.ico">

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap"
        rel="stylesheet">

    <!-- Styles -->
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/3d-theme.css">

    <style>
        /* Exam page specific styles */

        /* 3D Background Logo */
        .background-logo {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) perspective(1000px) rotateY(-5deg) rotateX(5deg);
            width: 60vw;
            max-width: 600px;
            opacity: 0.15;
            z-index: 0;
            pointer-events: none;
            animation: float3d 8s ease-in-out infinite;
            filter: drop-shadow(0 0 60px rgba(255, 107, 53, 0.4));
        }

        .background-logo img {
            width: 100%;
            height: auto;
        }

        @keyframes float3d {

            0%,
            100% {
                transform: translate(-50%, -50%) perspective(1000px) rotateY(-5deg) rotateX(5deg) translateZ(0);
            }

            25% {
                transform: translate(-50%, -50%) perspective(1000px) rotateY(3deg) rotateX(-3deg) translateZ(20px);
            }

            50% {
                transform: translate(-50%, -50%) perspective(1000px) rotateY(5deg) rotateX(5deg) translateZ(40px);
            }

            75% {
                transform: translate(-50%, -50%) perspective(1000px) rotateY(-3deg) rotateX(-5deg) translateZ(20px);
            }
        }

        /* Torch flame glow effect */
        .background-logo::after {
            content: '';
            position: absolute;
            top: 20%;
            right: 25%;
            width: 80px;
            height: 120px;
            background: radial-gradient(ellipse at center, rgba(255, 166, 0, 0.4) 0%, rgba(255, 107, 53, 0.2) 40%, transparent 70%);
            border-radius: 50% 50% 50% 50%;
            filter: blur(20px);
            animation: flameGlow 2s ease-in-out infinite alternate;
        }

        @keyframes flameGlow {
            0% {
                opacity: 0.5;
                transform: scale(1);
            }

            100% {
                opacity: 0.8;
                transform: scale(1.1);
            }
        }

        body {
            background: transparent !important;
            color: #fff;
        }

        .exam-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
        }

        .exam-header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--space-md) var(--space-lg);
            background: var(--surface-glass);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
        }

        .exam-info {
            display: flex;
            align-items: center;
            gap: var(--space-lg);
        }

        .exam-round-badge {
            padding: var(--space-xs) var(--space-md);
            background: var(--primary-glow);
            color: var(--primary-light);
            border-radius: var(--radius-full);
            font-weight: 600;
            font-size: 0.85rem;
        }

        .participant-info {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .exam-main {
            padding-top: 80px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .exam-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--space-xl);
        }

        .exam-question-container {
            width: 100%;
            max-width: 800px;
        }

        .exam-progress {
            margin-bottom: var(--space-xl);
        }

        .exam-progress-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: var(--space-sm);
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .exam-actions {
            display: flex;
            justify-content: flex-end;
            gap: var(--space-md);
            margin-top: var(--space-xl);
        }

        /* Warning overlay */
        .warning-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: hsla(0, 0%, 0%, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            text-align: center;
            padding: var(--space-xl);
        }

        .warning-overlay.hidden {
            display: none;
        }

        .warning-icon-large {
            width: 80px;
            height: 80px;
            background: var(--danger);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            margin-bottom: var(--space-xl);
            animation: pulse 1s infinite;
        }

        .warning-title {
            font-size: 2rem;
            color: var(--danger);
            margin-bottom: var(--space-md);
        }

        .warning-text {
            font-size: 1.1rem;
            color: var(--text-secondary);
            max-width: 500px;
            margin-bottom: var(--space-xl);
        }

        .warning-count {
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* Screen states */
        .screen {
            display: none;
        }

        .screen.active {
            display: flex;
        }

        /* Success checkmark animation */
        .completion-icon {
            animation: successPulse 2s ease-in-out infinite;
        }

        @keyframes successPulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.1);
                opacity: 0.9;
            }
        }
    </style>
</head>

<body>
    <!-- 3D Background Logo - VSBEC Kanal 2026 -->
    <div class="background-logo">
        <svg viewBox="0 0 400 200" xmlns="http://www.w3.org/2000/svg">
            <!-- Torch Handle -->
            <defs>
                <linearGradient id="flameGradient" x1="0%" y1="100%" x2="0%" y2="0%">
                    <stop offset="0%" style="stop-color:#ff6b35;stop-opacity:1" />
                    <stop offset="50%" style="stop-color:#ffa500;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#ffff00;stop-opacity:1" />
                </linearGradient>
                <filter id="glow">
                    <feGaussianBlur stdDeviation="3" result="coloredBlur" />
                    <feMerge>
                        <feMergeNode in="coloredBlur" />
                        <feMergeNode in="SourceGraphic" />
                    </feMerge>
                </filter>
            </defs>

            <!-- VSBEC Text -->
            <text x="80" y="70" font-family="Inter, Arial, sans-serif" font-size="28" font-weight="600"
                fill="rgba(255,255,255,0.9)" letter-spacing="8">VSBEC</text>

            <!-- Kanal Text (Large) -->
            <text x="50" y="130" font-family="Inter, Arial, sans-serif" font-size="60" font-weight="700"
                fill="rgba(255,255,255,0.95)" letter-spacing="2">Kanal</text>

            <!-- Torch -->
            <g transform="translate(240, 40)">
                <!-- Handle -->
                <rect x="15" y="60" width="12" height="50" rx="3" fill="#8B4513" />
                <rect x="10" y="55" width="22" height="12" rx="2" fill="#CD853F" />

                <!-- Flame -->
                <path d="M21 55 Q21 30, 10 20 Q15 35, 21 40 Q27 35, 32 20 Q21 30, 21 55" fill="url(#flameGradient)"
                    filter="url(#glow)">
                    <animate attributeName="d" values="M21 55 Q21 30, 10 20 Q15 35, 21 40 Q27 35, 32 20 Q21 30, 21 55;
                                M21 55 Q21 25, 8 15 Q16 32, 21 38 Q26 32, 34 15 Q21 25, 21 55;
                                M21 55 Q21 30, 10 20 Q15 35, 21 40 Q27 35, 32 20 Q21 30, 21 55" dur="1s"
                        repeatCount="indefinite" />
                </path>

                <!-- Inner flame -->
                <path d="M21 55 Q21 40, 16 35 Q19 42, 21 45 Q23 42, 26 35 Q21 40, 21 55" fill="#fff8dc" opacity="0.8">
                    <animate attributeName="d" values="M21 55 Q21 40, 16 35 Q19 42, 21 45 Q23 42, 26 35 Q21 40, 21 55;
                                M21 55 Q21 38, 14 32 Q18 40, 21 43 Q24 40, 28 32 Q21 38, 21 55;
                                M21 55 Q21 40, 16 35 Q19 42, 21 45 Q23 42, 26 35 Q21 40, 21 55" dur="0.8s"
                        repeatCount="indefinite" />
                </path>
            </g>

            <!-- 2026 Text -->
            <text x="220" y="170" font-family="Inter, Arial, sans-serif" font-size="36" font-weight="600"
                fill="rgba(255,255,255,0.85)" letter-spacing="4">2026</text>
        </svg>
    </div>

    <!-- 3D Background Logo - CURRENT CONQUEST -->
    <div class="background-logo logo-cc">
        <svg viewBox="0 0 500 300" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <linearGradient id="textGradient2" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:#ff9900;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#ff5500;stop-opacity:1" />
                </linearGradient>
                <filter id="ccGlow2">
                    <feGaussianBlur stdDeviation="4" result="coloredBlur" />
                    <feMerge>
                        <feMergeNode in="coloredBlur" />
                        <feMergeNode in="SourceGraphic" />
                    </feMerge>
                </filter>
            </defs>

            <!-- Mountain Icon -->
            <path d="M250 40 L290 90 L210 90 Z" fill="#fff" opacity="0.9" transform="translate(0, -10)" />
            <path d="M250 40 L270 90 L230 90 Z" fill="#eee" opacity="0.5" transform="translate(0, -10)" />

            <!-- CURRENT Text -->
            <text x="250" y="140" font-family="Arial Black, Impact, sans-serif" font-size="70" font-weight="900"
                font-style="italic" fill="#fff" text-anchor="middle" letter-spacing="2"
                transform="rotate(-5, 250, 150)">CURRENT</text>

            <!-- CONQUEST Text -->
            <text x="250" y="210" font-family="Arial Black, Impact, sans-serif" font-size="85" font-weight="900"
                font-style="italic" fill="url(#textGradient2)" text-anchor="middle" letter-spacing="1"
                filter="url(#ccGlow2)" transform="rotate(-5, 250, 150)">CONQUEST</text>

            <!-- Lightning Bolt -->
            <path d="M280 180 L240 240 L270 240 L230 300 L260 250 L230 250 L270 180 Z" fill="#ffcc00" stroke="#fff"
                stroke-width="2" transform="rotate(-15, 250, 240) translate(20, -20)" />

            <!-- Decor lines -->
            <path d="M50 160 L450 100" stroke="#ff9900" stroke-width="3" stroke-opacity="0.6" stroke-linecap="round" />
            <path d="M50 240 L450 180" stroke="#ff9900" stroke-width="3" stroke-opacity="0.6" stroke-linecap="round" />
        </svg>
    </div>

    <!-- 3D Canvas Container -->
    <div id="canvas-container"></div>

    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="logo">
            <div class="logo-icon">QC</div>
            <span class="title-gradient">Quiz Conquest</span>
        </div>
        <div class="spinner spinner-lg"></div>
    </div>

    <!-- Warning Overlay (Tab Switch) -->
    <div class="warning-overlay hidden" id="warningOverlay">
        <div class="warning-icon-large">âš ï¸</div>
        <h1 class="warning-title">Warning!</h1>
        <p class="warning-text" id="warningText">
            You switched tabs or windows. This is your first warning.
            Another violation will result in automatic submission.
        </p>
        <p class="warning-count" id="warningCount">Violations: 1/2</p>
        <button class="btn btn-danger btn-lg" id="dismissWarning">Continue Exam</button>
    </div>

    <!-- Waiting Screen -->
    <div class="screen waiting-screen" id="waitingScreen">
        <div class="waiting-animation"></div>
        <h1 class="waiting-title" id="waitingTitle">Waiting for Round to Start</h1>
        <p class="waiting-message" id="waitingMessage">
            Please wait. The coordinator will start the round shortly.
            Do not close this window.
        </p>
        <div id="tokenDisplay" style="margin-top: var(--space-xl); color: var(--text-muted);">
            <p>Your Token: <span id="displayToken"
                    style="font-family: 'JetBrains Mono', monospace; font-size: 0.8rem;">-</span></p>
        </div>
    </div>

    <!-- Exam Screen -->
    <div class="screen" id="examScreen" style="flex-direction: column;">
        <header class="exam-header">
            <div class="exam-header-content">
                <div class="exam-info">
                    <span class="exam-round-badge" id="roundBadge">Round 1</span>
                </div>
                <div class="exam-timer" id="examTimer">
                    <span>â±ï¸</span>
                    <span id="timerDisplay">15:00</span>
                </div>
                <div class="participant-info">
                    <span>ğŸ”‘</span>
                    <span class="badge badge-neutral" id="headerToken"
                        style="font-family: 'JetBrains Mono', monospace; font-size: 0.7rem;">Token</span>
                </div>
            </div>
        </header>

        <main class="exam-main">
            <div class="exam-content">
                <div class="exam-question-container">
                    <!-- Progress -->
                    <div class="exam-progress">
                        <div class="exam-progress-info">
                            <span>Question <span id="currentQuestionNum">1</span> of <span
                                    id="totalQuestions">15</span></span>
                            <span><span id="answeredCount">0</span> answered</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill" style="width: 0%;"></div>
                        </div>
                    </div>

                    <!-- Question Card -->
                    <div class="question-card" id="questionCard">
                        <span class="question-number" id="questionLabel">Question 1</span>
                        <p class="question-text" id="questionText">Loading question...</p>

                        <div class="options-list" id="optionsList">
                            <!-- Options will be rendered here -->
                        </div>

                        <div class="exam-actions">
                            <button class="btn btn-primary btn-lg" id="nextBtn">
                                <span id="nextBtnText">Next Question</span>
                                <span>â†’</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Completion Screen -->
    <div class="screen completion-screen" id="completionScreen">
        <div class="completion-icon">âœ“</div>
        <h1 class="completion-title">Exam Submitted!</h1>
        <p class="completion-message" id="completionMessage">
            Your answers have been successfully submitted.
            Please wait for the results. Do not close this window.
        </p>
        <div id="submissionInfo" style="color: var(--text-muted); font-size: 0.9rem;">
            <p>Submitted at: <span id="submissionTime">-</span></p>
        </div>
    </div>

    <script>
        /**
         * Quiz Conquest â€” Exam Page (V4 Architecture)
         *
         * ARCHITECTURE:
         *   â€¢ No login/registration â€” token generated on page load
         *   â€¢ attempt_token (UUID) stored in localStorage
         *   â€¢ All questions loaded in single API call
         *   â€¢ Answers stored in memory â€” no per-question API calls
         *   â€¢ Single bulk submission at end
         *   â€¢ Fully idempotent submission (duplicate = success)
         *   â€¢ NEVER shows "Failed to submit" â€” immediate success UI
         *   â€¢ Auto-retry on network failure
         *   â€¢ Checks submission status endpoint as final fallback
         */
        (function () {
            'use strict';

            // â”€â”€â”€ UUID Generator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            function generateUUID() {
                if (crypto.randomUUID) return crypto.randomUUID();
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                    const r = Math.random() * 16 | 0;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            }

            // â”€â”€â”€ Attempt Token Management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // Generate or retrieve existing attempt_token from localStorage
            function getOrCreateAttemptToken() {
                const STORAGE_KEY = 'qc_attempt_token';
                let token = localStorage.getItem(STORAGE_KEY);
                if (!token) {
                    token = generateUUID();
                    localStorage.setItem(STORAGE_KEY, token);
                }
                return token;
            }

            // Clear token (called after round ends)
            function clearAttemptToken() {
                localStorage.removeItem('qc_attempt_token');
                localStorage.removeItem('qc_submitted');
                localStorage.removeItem('qc_round');
            }

            // â”€â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const attemptToken = getOrCreateAttemptToken();

            let state = {
                currentRound: 0,
                roundStatus: 'not_started',
                roundEndsAt: null,
                currentQuestionNum: 1,
                selectedOption: null,
                isSubmitting: false,
                isSubmitted: false,
                timerInterval: null,
                statusInterval: null,
                tabSwitchCount: 0,
                serverTimeOffset: 0,
                totalQuestions: 15,
                // BULK SUBMISSION: Store all answers in memory
                answers: {},  // { questionId: selectedOption }
                examStartTime: null
            };

            // Check if already submitted
            if (localStorage.getItem('qc_submitted') === 'true') {
                state.isSubmitted = true;
            }

            // â”€â”€â”€ DOM Elements â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const screens = {
                loading: document.getElementById('loadingScreen'),
                waiting: document.getElementById('waitingScreen'),
                exam: document.getElementById('examScreen'),
                completion: document.getElementById('completionScreen')
            };

            const elements = {
                warningOverlay: document.getElementById('warningOverlay'),
                warningText: document.getElementById('warningText'),
                warningCount: document.getElementById('warningCount'),
                dismissWarning: document.getElementById('dismissWarning'),
                waitingTitle: document.getElementById('waitingTitle'),
                waitingMessage: document.getElementById('waitingMessage'),
                displayToken: document.getElementById('displayToken'),
                roundBadge: document.getElementById('roundBadge'),
                timerDisplay: document.getElementById('timerDisplay'),
                examTimer: document.getElementById('examTimer'),
                headerToken: document.getElementById('headerToken'),
                currentQuestionNum: document.getElementById('currentQuestionNum'),
                totalQuestions: document.getElementById('totalQuestions'),
                answeredCount: document.getElementById('answeredCount'),
                progressFill: document.getElementById('progressFill'),
                questionLabel: document.getElementById('questionLabel'),
                questionText: document.getElementById('questionText'),
                optionsList: document.getElementById('optionsList'),
                nextBtn: document.getElementById('nextBtn'),
                nextBtnText: document.getElementById('nextBtnText'),
                completionMessage: document.getElementById('completionMessage'),
                submissionTime: document.getElementById('submissionTime')
            };

            // Display token
            elements.displayToken.textContent = attemptToken.substring(0, 8) + '...';
            elements.headerToken.textContent = attemptToken.substring(0, 8);

            // â”€â”€â”€ API Helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            async function api(endpoint, options = {}) {
                const response = await fetch(endpoint, {
                    ...options,
                    headers: {
                        'Content-Type': 'application/json',
                        ...options.headers
                    }
                });
                return response.json();
            }

            // â”€â”€â”€ Show specific screen â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            function showScreen(screenName) {
                Object.values(screens).forEach(screen => {
                    screen.classList.remove('active');
                    screen.style.display = 'none';
                });

                if (screens[screenName]) {
                    screens[screenName].classList.add('active');
                    screens[screenName].style.display = 'flex';
                }
            }

            // â”€â”€â”€ Sync server time â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            async function syncServerTime() {
                try {
                    const start = Date.now();
                    const result = await api('/api/server-time');
                    const end = Date.now();
                    const latency = (end - start) / 2;

                    if (result.success) {
                        const serverTime = new Date(result.serverTime).getTime();
                        state.serverTimeOffset = serverTime - Date.now() + latency;
                    }
                } catch (error) {
                    console.error('Time sync error:', error);
                }
            }

            function getServerTime() {
                return Date.now() + state.serverTimeOffset;
            }

            // â”€â”€â”€ Format time â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            function formatTime(seconds) {
                if (seconds < 0) seconds = 0;
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }

            // â”€â”€â”€ Update timer display â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            function updateTimer() {
                if (!state.roundEndsAt) return;

                const now = getServerTime();
                const endTime = new Date(state.roundEndsAt).getTime();
                const remaining = Math.max(0, Math.floor((endTime - now) / 1000));

                elements.timerDisplay.textContent = formatTime(remaining);

                // Timer warnings
                if (remaining <= 60) {
                    elements.examTimer.classList.add('danger');
                    elements.examTimer.classList.remove('warning');
                } else if (remaining <= 180) {
                    elements.examTimer.classList.add('warning');
                    elements.examTimer.classList.remove('danger');
                } else {
                    elements.examTimer.classList.remove('warning', 'danger');
                }

                // Auto-submit when time expires
                if (remaining <= 0 && !state.isSubmitting && !state.isSubmitted) {
                    clearInterval(state.timerInterval);
                    // Save current answer before auto-submit
                    if (state.currentQuestion?.questionId && state.selectedOption) {
                        state.answers[state.currentQuestion.questionId] = state.selectedOption;
                    }
                    submitExam('auto_timer');
                }
            }

            // â”€â”€â”€ Start timer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            function startTimer() {
                if (state.timerInterval) {
                    clearInterval(state.timerInterval);
                }
                updateTimer();
                state.timerInterval = setInterval(updateTimer, 1000);
            }

            // â”€â”€â”€ Check status â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            async function checkStatus() {
                try {
                    // If already submitted, show completion
                    if (state.isSubmitted) {
                        showScreen('completion');
                        stopStatusPolling();
                        return;
                    }

                    const result = await api('/api/exam/status');

                    if (!result.success) {
                        console.error('Status check failed');
                        return;
                    }

                    const data = result.data;
                    state.currentRound = data.currentRound;
                    state.roundStatus = data.roundStatus;
                    state.roundEndsAt = data.roundEndsAt;

                    // Handle different states
                    if (data.roundStatus === 'running' && data.eventActive) {
                        // Check if we already submitted for this round
                        const storedRound = localStorage.getItem('qc_round');
                        if (storedRound && parseInt(storedRound) !== data.currentRound) {
                            // New round â€” clear old data
                            clearAttemptToken();
                            location.reload();
                            return;
                        }

                        // Load questions and start exam
                        await startExam(data.currentRound);
                        stopStatusPolling();
                    } else if (data.roundStatus === 'completed') {
                        // Check if we have results
                        updateWaitingScreen(data);
                        showScreen('waiting');
                    } else {
                        // Waiting for round to start
                        updateWaitingScreen(data);
                        showScreen('waiting');
                    }

                } catch (error) {
                    console.error('Status check error:', error);
                }
            }

            // â”€â”€â”€ Update waiting screen â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            function updateWaitingScreen(data) {
                if (!data.eventActive) {
                    elements.waitingTitle.textContent = 'Event Not Active';
                    elements.waitingMessage.textContent =
                        'The examination event has not started yet. Please wait for the coordinator.';
                } else if (data.currentRound === 0) {
                    elements.waitingTitle.textContent = 'Event Starting Soon';
                    elements.waitingMessage.textContent =
                        'The event has been activated. Please wait for Round 1 to begin.';
                } else if (data.roundStatus === 'completed') {
                    elements.waitingTitle.textContent = `Round ${data.currentRound} Completed`;
                    elements.waitingMessage.textContent =
                        'Please wait while results are being processed.';
                } else {
                    elements.waitingTitle.textContent = `Waiting for Round ${data.currentRound || 1}`;
                    elements.waitingMessage.textContent =
                        'Please wait. The coordinator will start the round shortly.';
                }
            }

            // â”€â”€â”€ Status Polling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            function startStatusPolling() {
                if (state.statusInterval) {
                    clearInterval(state.statusInterval);
                }
                state.statusInterval = setInterval(checkStatus, 3000);
            }

            function stopStatusPolling() {
                if (state.statusInterval) {
                    clearInterval(state.statusInterval);
                    state.statusInterval = null;
                }
            }

            // â”€â”€â”€ All questions stored in memory â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            let allQuestions = [];

            // â”€â”€â”€ Start exam â€” Load ALL questions at once â”€â”€â”€â”€â”€â”€â”€â”€
            async function startExam(roundNumber) {
                try {
                    const result = await api('/api/exam/questions');

                    if (!result.success || !result.data.questions || result.data.questions.length === 0) {
                        console.error('Failed to load questions');
                        // Retry once
                        await new Promise(r => setTimeout(r, 1000));
                        const retry = await api('/api/exam/questions');
                        if (retry.success && retry.data.questions) {
                            allQuestions = retry.data.questions;
                        } else {
                            elements.waitingTitle.textContent = 'Loading Questions...';
                            elements.waitingMessage.textContent = 'Questions are being loaded. Please wait.';
                            showScreen('waiting');
                            startStatusPolling();
                            return;
                        }
                    } else {
                        allQuestions = result.data.questions;
                    }

                    state.totalQuestions = allQuestions.length;
                    state.roundEndsAt = result.data?.roundEndsAt;
                    state.currentRound = roundNumber;
                    state.examStartTime = Date.now();
                    localStorage.setItem('qc_round', roundNumber.toString());

                    // Update UI
                    elements.roundBadge.textContent = `Round ${roundNumber}`;
                    elements.totalQuestions.textContent = state.totalQuestions;

                    // Display first question
                    displayQuestion(1);
                    showScreen('exam');
                    startTimer();

                } catch (error) {
                    console.error('Start exam error:', error);
                    // Keep waiting
                    startStatusPolling();
                }
            }

            // â”€â”€â”€ Display question (INSTANT â€” no network call) â”€â”€â”€
            function displayQuestion(questionNumber) {
                const question = allQuestions.find(q => q.questionNumber === questionNumber);
                if (!question) {
                    if (allQuestions.length === 0) {
                        elements.questionText.textContent = 'Failed to load questions. Please refresh the page.';
                    }
                    return;
                }

                state.currentQuestion = question;
                state.currentQuestionNum = questionNumber;

                // Restore previously selected answer if any
                state.selectedOption = state.answers[question.questionId] || null;

                // Update UI instantly
                elements.currentQuestionNum.textContent = questionNumber;
                elements.questionLabel.textContent = `Question ${questionNumber}`;
                elements.questionText.textContent = question.questionText;
                elements.progressFill.style.width = `${((questionNumber - 1) / state.totalQuestions) * 100}%`;
                elements.answeredCount.textContent = Object.keys(state.answers).length;

                // Update button text
                if (questionNumber >= state.totalQuestions) {
                    elements.nextBtnText.textContent = 'Submit Exam';
                } else {
                    elements.nextBtnText.textContent = 'Next Question';
                }

                // Render options
                renderOptions(question.options, state.selectedOption);
            }

            // â”€â”€â”€ Render options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            function renderOptions(options, selectedOption) {
                elements.optionsList.innerHTML = '';

                const optionKeys = ['A', 'B', 'C', 'D'];

                optionKeys.forEach(key => {
                    const optionItem = document.createElement('div');
                    optionItem.className = 'option-item';

                    const isChecked = selectedOption === key;

                    optionItem.innerHTML = `
                        <input 
                            type="radio" 
                            id="option${key}" 
                            name="answer" 
                            value="${key}" 
                            class="option-input"
                            ${isChecked ? 'checked' : ''}
                        >
                        <label for="option${key}" class="option-label">
                            <span class="option-indicator">${key}</span>
                            <span class="option-text">${options[key]}</span>
                        </label>
                    `;

                    const input = optionItem.querySelector('input');
                    input.addEventListener('change', () => {
                        state.selectedOption = key;
                    });

                    elements.optionsList.appendChild(optionItem);
                });
            }

            // â”€â”€â”€ Submit answer and go to next (INSTANT) â”€â”€â”€â”€â”€â”€â”€â”€â”€
            function submitAnswer() {
                if (state.isSubmitting || state.isSubmitted) return;

                const currentNum = state.currentQuestionNum;
                const isLastQuestion = currentNum >= state.totalQuestions;
                const savedQuestionId = state.currentQuestion?.questionId;
                const savedOption = state.selectedOption;

                // Store answer in memory (no API call)
                if (savedQuestionId && savedOption) {
                    state.answers[savedQuestionId] = savedOption;
                }

                if (isLastQuestion) {
                    // Last question â€” submit ALL answers
                    elements.nextBtn.disabled = true;
                    submitExam('manual');
                } else {
                    // INSTANT: Display next question (pure DOM, no network)
                    displayQuestion(currentNum + 1);
                }
            }

            // â”€â”€â”€ Submit exam with ALL answers (BULK SUBMISSION) â”€
            let submitRetryCount = 0;
            const MAX_SUBMIT_RETRIES = 3;

            async function submitExam(submissionType = 'manual') {
                // Guard: only one submission at a time
                if (state.isSubmitting && submissionType === 'manual') return;
                if (state.isSubmitted) {
                    showScreen('completion');
                    return;
                }

                state.isSubmitting = true;
                elements.nextBtn.disabled = true;

                // Calculate time taken
                const timeTaken = state.examStartTime
                    ? Math.floor((Date.now() - state.examStartTime) / 1000)
                    : 0;

                try {
                    // Convert answers object to array format
                    const answersArray = Object.entries(state.answers).map(([questionId, selectedOption]) => ({
                        question_id: questionId,
                        selected_option: selectedOption
                    }));

                    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    // IMMEDIATELY show success UI
                    // This is the "No Failure Message" policy
                    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    state.isSubmitted = true;
                    localStorage.setItem('qc_submitted', 'true');
                    clearInterval(state.timerInterval);
                    showScreen('completion');

                    if (submissionType === 'auto_timer') {
                        elements.completionMessage.textContent =
                            'Time\'s up! Your answers have been automatically submitted.';
                    } else {
                        elements.completionMessage.textContent =
                            'Your answers have been successfully submitted. Please wait for the results.';
                    }
                    elements.submissionTime.textContent = new Date().toLocaleTimeString();

                    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    // Send to backend (fire-and-forget with retry)
                    // UI already shows success â€” this is best-effort
                    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    const result = await api('/api/exam/submit', {
                        method: 'POST',
                        body: JSON.stringify({
                            attempt_token: attemptToken,
                            round_number: state.currentRound,
                            answers: answersArray,
                            time_taken_seconds: timeTaken
                        })
                    });

                    if (result.success) {
                        submitRetryCount = 0;
                        console.log('âœ… Submission confirmed by server');
                    } else {
                        throw new Error('Server returned non-success');
                    }

                } catch (error) {
                    console.error('Submit error (retrying):', error);
                    submitRetryCount++;

                    if (submitRetryCount < MAX_SUBMIT_RETRIES) {
                        // Retry in background â€” UI already shows success
                        setTimeout(() => retrySubmission(submissionType), 1000 * submitRetryCount);
                    } else {
                        // Check submission status as fallback
                        checkSubmissionStatus();
                    }
                } finally {
                    state.isSubmitting = false;
                }
            }

            // â”€â”€â”€ Retry submission in background â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            async function retrySubmission(submissionType) {
                try {
                    const timeTaken = state.examStartTime
                        ? Math.floor((Date.now() - state.examStartTime) / 1000)
                        : 0;

                    const answersArray = Object.entries(state.answers).map(([questionId, selectedOption]) => ({
                        question_id: questionId,
                        selected_option: selectedOption
                    }));

                    const result = await api('/api/exam/submit', {
                        method: 'POST',
                        body: JSON.stringify({
                            attempt_token: attemptToken,
                            round_number: state.currentRound,
                            answers: answersArray,
                            time_taken_seconds: timeTaken
                        })
                    });

                    if (result.success) {
                        submitRetryCount = 0;
                        console.log('âœ… Retry submission confirmed');
                    } else {
                        throw new Error('Retry non-success');
                    }
                } catch (error) {
                    submitRetryCount++;
                    if (submitRetryCount < MAX_SUBMIT_RETRIES) {
                        setTimeout(() => retrySubmission(submissionType), 1000 * submitRetryCount);
                    } else {
                        checkSubmissionStatus();
                    }
                }
            }

            // â”€â”€â”€ Check submission status (final fallback) â”€â”€â”€â”€â”€â”€â”€
            async function checkSubmissionStatus() {
                try {
                    const result = await api(`/api/exam/submission-status/${attemptToken}`);
                    if (result.submitted) {
                        console.log('âœ… Submission verified via status check');
                    } else {
                        console.warn('âš  Submission may not have been recorded. Retrying one last time.');
                        // One final retry
                        retrySubmission('fallback');
                    }
                } catch (error) {
                    console.error('Status check failed:', error);
                    // UI already shows success â€” don't panic
                }
            }

            // â”€â”€â”€ Handle tab switch/visibility change â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            function handleVisibilityChange() {
                if (document.hidden && screens.exam.classList.contains('active') && !state.isSubmitting && !state.isSubmitted) {
                    state.tabSwitchCount++;

                    // Save current answer
                    if (state.currentQuestion?.questionId && state.selectedOption) {
                        state.answers[state.currentQuestion.questionId] = state.selectedOption;
                    }

                    if (state.tabSwitchCount >= 2) {
                        // 2nd+ switch â†’ auto-submit
                        submitExam('auto_violation');
                    } else {
                        // 1st switch â†’ warning
                        elements.warningText.textContent =
                            'âš ï¸ CRITICAL WARNING: You switched tabs or windows during the exam. ' +
                            'This is your FIRST and ONLY warning. ' +
                            'If you switch again, your exam will be auto-submitted.';
                        elements.warningCount.textContent = `Violations: ${state.tabSwitchCount} / 2 (next = auto-submit)`;
                        elements.warningOverlay.classList.remove('hidden');
                    }
                }
            }

            // â”€â”€â”€ Handle page refresh attempt â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            function handleBeforeUnload(e) {
                if (screens.exam.classList.contains('active') && !state.isSubmitted) {
                    e.preventDefault();
                    e.returnValue = 'Your exam is in progress. Are you sure you want to leave?';
                    return e.returnValue;
                }
            }

            // â”€â”€â”€ Dismiss warning â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            function dismissWarning() {
                elements.warningOverlay.classList.add('hidden');
            }

            // â”€â”€â”€ Initialize â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            async function init() {
                await syncServerTime();

                // If already submitted, show completion immediately
                if (state.isSubmitted) {
                    showScreen('completion');
                    elements.completionMessage.textContent =
                        'Your answers have been submitted. Please wait for the results.';
                    return;
                }

                await checkStatus();
                startStatusPolling();

                // Event listeners
                elements.nextBtn.addEventListener('click', submitAnswer);
                elements.dismissWarning.addEventListener('click', dismissWarning);
                document.addEventListener('visibilitychange', handleVisibilityChange);
                window.addEventListener('beforeunload', handleBeforeUnload);

                // Prevent right-click context menu
                document.addEventListener('contextmenu', (e) => {
                    if (screens.exam.classList.contains('active')) {
                        e.preventDefault();
                    }
                });

                // Prevent keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (screens.exam.classList.contains('active')) {
                        if ((e.ctrlKey && ['c', 'v', 'a', 'u'].includes(e.key.toLowerCase())) ||
                            e.key === 'F12') {
                            e.preventDefault();
                        }
                    }
                });
            }

            init();
        })();
    </script>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        /**
         * Isometric Cyber Platform Animation
         * Based on user reference: Layered glass/tech platform in Blue/Cyan theme
         */
        (function () {
            const container = document.getElementById('canvas-container');
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050a14);
            scene.fog = new THREE.FogExp2(0x050a14, 0.02);

            const aspect = window.innerWidth / window.innerHeight;
            const d = 20;
            const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);

            camera.position.set(20, 20, 20);
            camera.lookAt(scene.position);

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            const blueLight = new THREE.PointLight(0x0088ff, 2, 50);
            blueLight.position.set(-5, 10, -5);
            scene.add(blueLight);

            const cyanLight = new THREE.PointLight(0x00ffff, 1.5, 40);
            cyanLight.position.set(5, 5, 5);
            scene.add(cyanLight);

            const platformGroup = new THREE.Group();
            scene.add(platformGroup);

            function createRoundedBoxShape(width, height, radius) {
                const shape = new THREE.Shape();
                const x = -width / 2;
                const y = -height / 2;

                shape.moveTo(x, y + radius);
                shape.lineTo(x, y + height - radius);
                shape.quadraticCurveTo(x, y + height, x + radius, y + height);
                shape.lineTo(x + width - radius, y + height);
                shape.quadraticCurveTo(x + width, y + height, x + width, y + height - radius);
                shape.lineTo(x + width, y + radius);
                shape.quadraticCurveTo(x + width, y, x + width - radius, y);
                shape.lineTo(x + radius, y);
                shape.quadraticCurveTo(x, y, x, y + radius);

                return shape;
            }

            const baseSize = 12;
            const baseShape = createRoundedBoxShape(baseSize, baseSize, 1);
            const baseGeometry = new THREE.ExtrudeGeometry(baseShape, {
                depth: 1.5,
                bevelEnabled: true,
                bevelSegments: 2,
                bevelSize: 0.1,
                bevelThickness: 0.1
            });
            baseGeometry.rotateX(Math.PI / 2);

            const ledCanvas = document.createElement('canvas');
            ledCanvas.width = 128;
            ledCanvas.height = 128;
            const ctx = ledCanvas.getContext('2d');
            ctx.fillStyle = '#001133';
            ctx.fillRect(0, 0, 128, 128);
            ctx.fillStyle = '#00ccff';

            for (let i = 0; i < 128; i += 8) {
                for (let j = 0; j < 128; j += 8) {
                    if ((i + j) % 16 === 0) {
                        ctx.beginPath();
                        ctx.arc(i + 4, j + 4, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            const ledTexture = new THREE.CanvasTexture(ledCanvas);
            ledTexture.wrapS = THREE.RepeatWrapping;
            ledTexture.wrapT = THREE.RepeatWrapping;
            ledTexture.minFilter = THREE.NearestFilter;
            ledTexture.magFilter = THREE.NearestFilter;

            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000,
                emissive: 0x0044aa,
                emissiveMap: ledTexture,
                emissiveIntensity: 2.0,
                roughness: 0.4,
                metalness: 0.8
            });
            const baseMesh = new THREE.Mesh(baseGeometry, [baseMaterial, baseMaterial]);
            baseMesh.position.y = -2;
            platformGroup.add(baseMesh);

            const midShape = createRoundedBoxShape(baseSize - 0.5, baseSize - 0.5, 0.8);
            const midGeometry = new THREE.ExtrudeGeometry(midShape, {
                depth: 0.5,
                bevelEnabled: true,
                bevelSize: 0.1,
                bevelThickness: 0.1
            });
            midGeometry.rotateX(Math.PI / 2);
            const midMaterial = new THREE.MeshStandardMaterial({
                color: 0x111111,
                roughness: 0.2,
                metalness: 0.9,
            });
            const midMesh = new THREE.Mesh(midGeometry, midMaterial);
            midMesh.position.y = -0.5;
            platformGroup.add(midMesh);

            const glassShape = createRoundedBoxShape(baseSize - 1, baseSize - 1, 0.6);
            const glassGeometry = new THREE.ExtrudeGeometry(glassShape, {
                depth: 0.2,
                bevelEnabled: true,
                bevelSize: 0.1,
                bevelThickness: 0.1
            });
            glassGeometry.rotateX(Math.PI / 2);
            const glassMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x000000,
                metalness: 0.1,
                roughness: 0.1,
                transmission: 0.9,
                opacity: 0.8,
                transparent: true,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1
            });
            const glassMesh = new THREE.Mesh(glassGeometry, glassMaterial);
            glassMesh.position.y = 0.2;
            platformGroup.add(glassMesh);

            const shapePoints = glassShape.getPoints(50);
            const borderGeo = new THREE.BufferGeometry().setFromPoints(shapePoints);
            borderGeo.rotateX(Math.PI / 2);
            const borderMat = new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 2 });
            const borderMesh = new THREE.LineLoop(borderGeo, borderMat);
            borderMesh.position.y = 0.42;
            platformGroup.add(borderMesh);

            const particlesGroup = new THREE.Group();
            platformGroup.add(particlesGroup);

            const pGeo = new THREE.OctahedronGeometry(0.2);
            const pMat = new THREE.MeshBasicMaterial({ color: 0x00ccff });
            for (let i = 0; i < 15; i++) {
                const mesh = new THREE.Mesh(pGeo, pMat);
                mesh.position.set(
                    (Math.random() - 0.5) * 8,
                    2 + Math.random() * 4,
                    (Math.random() - 0.5) * 8
                );
                mesh.userData = {
                    speed: 0.02 + Math.random() * 0.02,
                    offset: Math.random() * Math.PI * 2
                };
                particlesGroup.add(mesh);
            }

            const cursorShape = new THREE.Shape();
            cursorShape.moveTo(0, 2);
            cursorShape.lineTo(1.5, -2);
            cursorShape.lineTo(0, -1);
            cursorShape.lineTo(-1.5, -2);
            cursorShape.lineTo(0, 2);

            const cursorGeo = new THREE.ExtrudeGeometry(cursorShape, { depth: 0.5, bevelEnabled: true, bevelSize: 0.1, bevelThickness: 0.1 });
            cursorGeo.rotateX(Math.PI / 2);
            cursorGeo.rotateX(-Math.PI / 4);

            const cursorMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                emissive: 0x00ffff,
                emissiveIntensity: 0.5,
                metalness: 0.8,
                roughness: 0.2
            });
            const cursorMesh = new THREE.Mesh(cursorGeo, cursorMat);
            cursorMesh.position.set(0, 1.5, 0);
            platformGroup.add(cursorMesh);

            let time = 0;
            function animate() {
                requestAnimationFrame(animate);
                time += 0.02;

                platformGroup.position.y = Math.sin(time * 0.5) * 0.2;

                particlesGroup.rotation.y = time * 0.2;
                particlesGroup.children.forEach(p => {
                    p.position.y += Math.sin(time + p.userData.offset) * 0.02;
                });

                cursorMesh.rotation.y = Math.sin(time * 1.5) * 0.2;
                cursorMesh.position.y = 1.5 + Math.sin(time * 2) * 0.3;

                renderer.render(scene, camera);
            }

            window.addEventListener('resize', () => {
                const aspect = window.innerWidth / window.innerHeight;
                camera.left = -d * aspect;
                camera.right = d * aspect;
                camera.top = d;
                camera.bottom = -d;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
        })();
    </script>
</body>

</html>