<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Quiz Conquest - Examination Portal">
    <meta name="robots" content="noindex, nofollow">
    <title>Examination | Quiz Conquest</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <link rel="alternate icon" href="/favicon.ico">

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap"
        rel="stylesheet">

    <!-- Styles -->
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/3d-theme.css">

    <style>
        /* Exam page specific styles */

        /* 3D Background Logo */
        .background-logo {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) perspective(1000px) rotateY(-5deg) rotateX(5deg);
            width: 60vw;
            max-width: 600px;
            opacity: 0.08;
            z-index: 0;
            pointer-events: none;
            animation: float3d 8s ease-in-out infinite;
            filter: drop-shadow(0 0 60px rgba(255, 107, 53, 0.3));
        }

        .background-logo img {
            width: 100%;
            height: auto;
        }

        @keyframes float3d {

            0%,
            100% {
                transform: translate(-50%, -50%) perspective(1000px) rotateY(-5deg) rotateX(5deg) translateZ(0);
            }

            25% {
                transform: translate(-50%, -50%) perspective(1000px) rotateY(3deg) rotateX(-3deg) translateZ(20px);
            }

            50% {
                transform: translate(-50%, -50%) perspective(1000px) rotateY(5deg) rotateX(5deg) translateZ(40px);
            }

            75% {
                transform: translate(-50%, -50%) perspective(1000px) rotateY(-3deg) rotateX(-5deg) translateZ(20px);
            }
        }

        /* Torch flame glow effect */
        .background-logo::after {
            content: '';
            position: absolute;
            top: 20%;
            right: 25%;
            width: 80px;
            height: 120px;
            background: radial-gradient(ellipse at center, rgba(255, 166, 0, 0.4) 0%, rgba(255, 107, 53, 0.2) 40%, transparent 70%);
            border-radius: 50% 50% 50% 50%;
            filter: blur(20px);
            animation: flameGlow 2s ease-in-out infinite alternate;
        }

        @keyframes flameGlow {
            0% {
                opacity: 0.5;
                transform: scale(1);
            }

            100% {
                opacity: 0.8;
                transform: scale(1.1);
            }
        }

        body {
            background: transparent !important;
            color: #fff;
        }

        .exam-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
        }

        .exam-header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--space-md) var(--space-lg);
            background: var(--surface-glass);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border-color);
        }

        .exam-info {
            display: flex;
            align-items: center;
            gap: var(--space-lg);
        }

        .exam-round-badge {
            padding: var(--space-xs) var(--space-md);
            background: var(--primary-glow);
            color: var(--primary-light);
            border-radius: var(--radius-full);
            font-weight: 600;
            font-size: 0.85rem;
        }

        .participant-info {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .exam-main {
            padding-top: 80px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .exam-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--space-xl);
        }

        .exam-question-container {
            width: 100%;
            max-width: 800px;
        }

        .exam-progress {
            margin-bottom: var(--space-xl);
        }

        .exam-progress-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: var(--space-sm);
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .exam-actions {
            display: flex;
            justify-content: flex-end;
            gap: var(--space-md);
            margin-top: var(--space-xl);
        }

        /* Warning overlay */
        .warning-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: hsla(0, 0%, 0%, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            text-align: center;
            padding: var(--space-xl);
        }

        .warning-overlay.hidden {
            display: none;
        }

        .warning-icon-large {
            width: 80px;
            height: 80px;
            background: var(--danger);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            margin-bottom: var(--space-xl);
            animation: pulse 1s infinite;
        }

        .warning-title {
            font-size: 2rem;
            color: var(--danger);
            margin-bottom: var(--space-md);
        }

        .warning-text {
            font-size: 1.1rem;
            color: var(--text-secondary);
            max-width: 500px;
            margin-bottom: var(--space-xl);
        }

        .warning-count {
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* Screen states */
        .screen {
            display: none;
        }

        .screen.active {
            display: flex;
        }
    </style>
</head>

<body>
    <!-- 3D Background Logo - VSBEC Kanal 2026 -->
    <div class="background-logo">
        <svg viewBox="0 0 400 200" xmlns="http://www.w3.org/2000/svg">
            <!-- Torch Handle -->
            <defs>
                <linearGradient id="flameGradient" x1="0%" y1="100%" x2="0%" y2="0%">
                    <stop offset="0%" style="stop-color:#ff6b35;stop-opacity:1" />
                    <stop offset="50%" style="stop-color:#ffa500;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#ffff00;stop-opacity:1" />
                </linearGradient>
                <filter id="glow">
                    <feGaussianBlur stdDeviation="3" result="coloredBlur" />
                    <feMerge>
                        <feMergeNode in="coloredBlur" />
                        <feMergeNode in="SourceGraphic" />
                    </feMerge>
                </filter>
            </defs>

            <!-- VSBEC Text -->
            <text x="80" y="70" font-family="Inter, Arial, sans-serif" font-size="28" font-weight="600"
                fill="rgba(255,255,255,0.9)" letter-spacing="8">VSBEC</text>

            <!-- Kanal Text (Large) -->
            <text x="50" y="130" font-family="Inter, Arial, sans-serif" font-size="60" font-weight="700"
                fill="rgba(255,255,255,0.95)" letter-spacing="2">Kanal</text>

            <!-- Torch -->
            <g transform="translate(280, 40)">
                <!-- Handle -->
                <rect x="15" y="60" width="12" height="50" rx="3" fill="#8B4513" />
                <rect x="10" y="55" width="22" height="12" rx="2" fill="#CD853F" />

                <!-- Flame -->
                <path d="M21 55 Q21 30, 10 20 Q15 35, 21 40 Q27 35, 32 20 Q21 30, 21 55" fill="url(#flameGradient)"
                    filter="url(#glow)">
                    <animate attributeName="d" values="M21 55 Q21 30, 10 20 Q15 35, 21 40 Q27 35, 32 20 Q21 30, 21 55;
                                M21 55 Q21 25, 8 15 Q16 32, 21 38 Q26 32, 34 15 Q21 25, 21 55;
                                M21 55 Q21 30, 10 20 Q15 35, 21 40 Q27 35, 32 20 Q21 30, 21 55" dur="1s"
                        repeatCount="indefinite" />
                </path>

                <!-- Inner flame -->
                <path d="M21 55 Q21 40, 16 35 Q19 42, 21 45 Q23 42, 26 35 Q21 40, 21 55" fill="#fff8dc" opacity="0.8">
                    <animate attributeName="d" values="M21 55 Q21 40, 16 35 Q19 42, 21 45 Q23 42, 26 35 Q21 40, 21 55;
                                M21 55 Q21 38, 14 32 Q18 40, 21 43 Q24 40, 28 32 Q21 38, 21 55;
                                M21 55 Q21 40, 16 35 Q19 42, 21 45 Q23 42, 26 35 Q21 40, 21 55" dur="0.8s"
                        repeatCount="indefinite" />
                </path>
            </g>

            <!-- 2026 Text -->
            <text x="220" y="170" font-family="Inter, Arial, sans-serif" font-size="36" font-weight="600"
                fill="rgba(255,255,255,0.85)" letter-spacing="4">2026</text>
        </svg>
    </div>

    <!-- 3D Canvas Container -->
    <div id="canvas-container"></div>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="logo">
            <div class="logo-icon">QC</div>
            <span class="title-gradient">Quiz Conquest</span>
        </div>
        <div class="spinner spinner-lg"></div>
    </div>

    <!-- Warning Overlay (Tab Switch) -->
    <div class="warning-overlay hidden" id="warningOverlay">
        <div class="warning-icon-large">‚ö†Ô∏è</div>
        <h1 class="warning-title">Warning!</h1>
        <p class="warning-text" id="warningText">
            You switched tabs or windows. This is your first warning.
            Another violation will result in automatic submission.
        </p>
        <p class="warning-count" id="warningCount">Violations: 1/2</p>
        <button class="btn btn-danger btn-lg" id="dismissWarning">Continue Exam</button>
    </div>

    <!-- Not Logged In Screen -->
    <div class="screen waiting-screen" id="notLoggedIn">
        <div class="waiting-animation"></div>
        <h1 class="waiting-title">Session Expired</h1>
        <p class="waiting-message">Your session has expired or you are not logged in. Please login again to continue.
        </p>
        <a href="/" class="btn btn-primary btn-lg" style="margin-top: var(--space-xl);">Go to Login</a>
    </div>

    <!-- Waiting Screen -->
    <div class="screen waiting-screen" id="waitingScreen">
        <div class="waiting-animation"></div>
        <h1 class="waiting-title" id="waitingTitle">Waiting for Round to Start</h1>
        <p class="waiting-message" id="waitingMessage">
            Please wait. The coordinator will start the round shortly.
            Do not close this window.
        </p>
        <div id="participantInfoDisplay" style="margin-top: var(--space-xl); color: var(--text-muted);">
            <p>Logged in as: <span id="displayName">-</span></p>
            <p>System ID: <span id="displaySystemId">-</span></p>
        </div>
    </div>

    <!-- Not Qualified Screen -->
    <div class="screen waiting-screen" id="notQualifiedScreen">
        <div style="font-size: 5rem; margin-bottom: var(--space-xl);">üòî</div>
        <h1 class="waiting-title">Not Qualified</h1>
        <p class="waiting-message">
            Unfortunately, you did not qualify for the next round.
            Thank you for participating in Quiz Conquest!
        </p>
    </div>

    <!-- Disqualified Screen -->
    <div class="screen waiting-screen" id="disqualifiedScreen">
        <div style="font-size: 5rem; margin-bottom: var(--space-xl);">üö´</div>
        <h1 class="waiting-title text-danger">Disqualified</h1>
        <p class="waiting-message" id="disqualificationReason">
            You have been disqualified from the examination.
        </p>
    </div>

    <!-- Exam Screen -->
    <div class="screen" id="examScreen" style="flex-direction: column;">
        <header class="exam-header">
            <div class="exam-header-content">
                <div class="exam-info">
                    <!-- Logo Removed -->
                    <span class="exam-round-badge" id="roundBadge">Round 1</span>
                </div>
                <div class="exam-timer" id="examTimer">
                    <span>‚è±Ô∏è</span>
                    <span id="timerDisplay">15:00</span>
                </div>
                <div class="participant-info">
                    <span>üë§</span>
                    <span id="headerName">Participant</span>
                    <span class="badge badge-neutral" id="headerSystemId">QC-00000</span>
                </div>
            </div>
        </header>

        <main class="exam-main">
            <div class="exam-content">
                <div class="exam-question-container">
                    <!-- Progress -->
                    <div class="exam-progress">
                        <div class="exam-progress-info">
                            <span>Question <span id="currentQuestionNum">1</span> of 15</span>
                            <span><span id="answeredCount">0</span> answered</span>
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill" style="width: 0%;"></div>
                        </div>
                    </div>

                    <!-- Question Card -->
                    <div class="question-card" id="questionCard">
                        <span class="question-number" id="questionLabel">Question 1</span>
                        <p class="question-text" id="questionText">Loading question...</p>

                        <div class="options-list" id="optionsList">
                            <!-- Options will be rendered here -->
                        </div>

                        <div class="exam-actions">
                            <button class="btn btn-primary btn-lg" id="nextBtn">
                                <span id="nextBtnText">Next Question</span>
                                <span>‚Üí</span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Completion Screen -->
    <div class="screen completion-screen" id="completionScreen">
        <div class="completion-icon">‚úì</div>
        <h1 class="completion-title">Exam Submitted!</h1>
        <p class="completion-message" id="completionMessage">
            Your answers have been successfully submitted.
            Please wait for the results. Do not close this window.
        </p>
        <div id="submissionInfo" style="color: var(--text-muted); font-size: 0.9rem;">
            <p>Submitted at: <span id="submissionTime">-</span></p>
        </div>
    </div>

    <script>
        /**
         * Quiz Conquest - Exam Page
         * Strict exam mode with server-authoritative timer
         */
        (function () {
            'use strict';

            // State
            let state = {
                participant: null,
                currentRound: 0,
                roundStatus: 'not_started',
                roundEndsAt: null,
                examSession: null,
                currentQuestion: null,
                currentQuestionNum: 1,  // MNC STYLE: Track current question number
                selectedOption: null,
                isSubmitting: false,
                timerInterval: null,
                statusInterval: null,
                tabSwitchCount: 0,
                serverTimeOffset: 0,
                // BULK SUBMISSION: Store all answers in memory (no per-question DB calls)
                answers: {}  // { questionId: selectedOption }
            };

            // DOM Elements
            const screens = {
                loading: document.getElementById('loadingScreen'),
                notLoggedIn: document.getElementById('notLoggedIn'),
                waiting: document.getElementById('waitingScreen'),
                notQualified: document.getElementById('notQualifiedScreen'),
                disqualified: document.getElementById('disqualifiedScreen'),
                exam: document.getElementById('examScreen'),
                completion: document.getElementById('completionScreen')
            };

            const elements = {
                warningOverlay: document.getElementById('warningOverlay'),
                warningText: document.getElementById('warningText'),
                warningCount: document.getElementById('warningCount'),
                dismissWarning: document.getElementById('dismissWarning'),
                waitingTitle: document.getElementById('waitingTitle'),
                waitingMessage: document.getElementById('waitingMessage'),
                displayName: document.getElementById('displayName'),
                displaySystemId: document.getElementById('displaySystemId'),
                roundBadge: document.getElementById('roundBadge'),
                timerDisplay: document.getElementById('timerDisplay'),
                examTimer: document.getElementById('examTimer'),
                headerName: document.getElementById('headerName'),
                headerSystemId: document.getElementById('headerSystemId'),
                currentQuestionNum: document.getElementById('currentQuestionNum'),
                answeredCount: document.getElementById('answeredCount'),
                progressFill: document.getElementById('progressFill'),
                questionLabel: document.getElementById('questionLabel'),
                questionText: document.getElementById('questionText'),
                optionsList: document.getElementById('optionsList'),
                nextBtn: document.getElementById('nextBtn'),
                nextBtnText: document.getElementById('nextBtnText'),
                completionMessage: document.getElementById('completionMessage'),
                submissionTime: document.getElementById('submissionTime'),
                disqualificationReason: document.getElementById('disqualificationReason')
            };

            // API Helper
            async function api(endpoint, options = {}) {
                const response = await fetch(endpoint, {
                    ...options,
                    headers: {
                        'Content-Type': 'application/json',
                        ...options.headers
                    },
                    credentials: 'include'
                });
                return response.json();
            }

            // Show specific screen
            function showScreen(screenName) {
                Object.values(screens).forEach(screen => {
                    screen.classList.remove('active');
                    screen.style.display = 'none';
                });

                if (screens[screenName]) {
                    screens[screenName].classList.add('active');
                    screens[screenName].style.display = screenName === 'exam' ? 'flex' : 'flex';
                }
            }

            // Sync server time
            async function syncServerTime() {
                try {
                    const start = Date.now();
                    const result = await api('/api/server-time');
                    const end = Date.now();
                    const latency = (end - start) / 2;

                    if (result.success) {
                        const serverTime = new Date(result.serverTime).getTime();
                        state.serverTimeOffset = serverTime - Date.now() + latency;
                    }
                } catch (error) {
                    console.error('Time sync error:', error);
                }
            }

            // Get corrected current time
            function getServerTime() {
                return Date.now() + state.serverTimeOffset;
            }

            // Format time as MM:SS
            function formatTime(seconds) {
                if (seconds < 0) seconds = 0;
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }

            // Update timer display
            function updateTimer() {
                if (!state.roundEndsAt) return;

                const now = getServerTime();
                const endTime = new Date(state.roundEndsAt).getTime();
                const remaining = Math.max(0, Math.floor((endTime - now) / 1000));

                elements.timerDisplay.textContent = formatTime(remaining);

                // Timer warnings
                if (remaining <= 60) {
                    elements.examTimer.classList.add('danger');
                    elements.examTimer.classList.remove('warning');
                } else if (remaining <= 180) {
                    elements.examTimer.classList.add('warning');
                    elements.examTimer.classList.remove('danger');
                } else {
                    elements.examTimer.classList.remove('warning', 'danger');
                }

                // Auto-submit when time expires
                if (remaining <= 0 && !state.isSubmitting) {
                    clearInterval(state.timerInterval);
                    // CRITICAL: Save current answer before auto-submit
                    if (state.currentQuestion?.questionId && state.selectedOption) {
                        state.answers[state.currentQuestion.questionId] = state.selectedOption;
                    }
                    submitExam('auto_timer');
                }
            }

            // Start timer
            function startTimer() {
                if (state.timerInterval) {
                    clearInterval(state.timerInterval);
                }
                updateTimer();
                state.timerInterval = setInterval(updateTimer, 1000);
            }

            // Check session and status
            async function checkSession() {
                try {
                    const result = await api('/api/participant/session');

                    if (!result.success || !result.authenticated) {
                        showScreen('notLoggedIn');
                        return;
                    }

                    state.participant = {
                        systemId: result.data.systemId,
                        name: result.data.name
                    };

                    // Update UI with participant info
                    elements.displayName.textContent = result.data.name;
                    elements.displaySystemId.textContent = result.data.systemId;
                    elements.headerName.textContent = result.data.name;
                    elements.headerSystemId.textContent = result.data.systemId;

                    // Check qualification status
                    if (result.data.isDisqualified) {
                        elements.disqualificationReason.textContent =
                            result.data.disqualificationReason || 'You have been disqualified from the examination.';
                        showScreen('disqualified');
                        return;
                    }

                    // Handle exam session if exists and submitted
                    if (result.data.examSession && result.data.examSession.isSubmitted) {
                        showScreen('completion');
                        elements.completionMessage.textContent =
                            'Your answers have been submitted. Please wait for the results.';
                        return;
                    }

                    // Initial status check
                    await checkStatus();

                } catch (error) {
                    console.error('Session check error:', error);
                    showScreen('notLoggedIn');
                }
            }

            // Check current status
            async function checkStatus() {
                try {
                    const result = await api('/api/participant/status');

                    if (!result.success) {
                        console.error('Status check failed:', result.message);
                        return;
                    }

                    const data = result.data;
                    state.currentRound = data.currentRound;
                    state.roundStatus = data.roundStatus;
                    state.roundEndsAt = data.roundEndsAt;

                    // Check if not qualified
                    if (!data.canParticipate && data.currentRound > 0 && !data.isQualified) {
                        showScreen('notQualified');
                        stopStatusPolling();
                        return;
                    }

                    // Handle different states
                    if (data.roundStatus === 'running' && data.canParticipate) {
                        // Check if already submitted
                        if (data.examSession && data.examSession.isSubmitted) {
                            showScreen('completion');
                            stopStatusPolling();
                            return;
                        }

                        // Start or resume exam
                        if (!data.examSession) {
                            await startExam();
                        } else {
                            state.examSession = data.examSession;
                            state.tabSwitchCount = data.examSession.tabSwitchCount || 0;
                            await loadQuestion(data.examSession.currentQuestion);
                            showScreen('exam');
                            startTimer();
                        }
                        stopStatusPolling();
                    } else if (data.roundStatus === 'completed' && data.examSession && data.examSession.isSubmitted) {
                        showScreen('completion');
                        stopStatusPolling();
                    } else {
                        // Waiting for round to start
                        updateWaitingScreen(data);
                        showScreen('waiting');
                    }

                } catch (error) {
                    console.error('Status check error:', error);
                }
            }

            // Update waiting screen
            function updateWaitingScreen(data) {
                if (data.currentRound === 0) {
                    elements.waitingTitle.textContent = 'Event Starting Soon';
                    elements.waitingMessage.textContent =
                        'The event has been activated. Please wait for Round 1 to begin.';
                } else if (data.roundStatus === 'completed') {
                    elements.waitingTitle.textContent = `Round ${data.currentRound} Completed`;
                    elements.waitingMessage.textContent =
                        'Please wait while results are being processed.';
                } else {
                    elements.waitingTitle.textContent = `Waiting for Round ${data.currentRound || 1}`;
                    elements.waitingMessage.textContent =
                        'Please wait. The coordinator will start the round shortly.';
                }
            }

            // Start status polling
            function startStatusPolling() {
                if (state.statusInterval) {
                    clearInterval(state.statusInterval);
                }
                state.statusInterval = setInterval(checkStatus, 3000);
            }

            // Stop status polling
            function stopStatusPolling() {
                if (state.statusInterval) {
                    clearInterval(state.statusInterval);
                    state.statusInterval = null;
                }
            }

            // Start exam - MNC STYLE: Load ALL questions at once
            async function startExam() {
                try {
                    const result = await api('/api/participant/start-exam', {
                        method: 'POST'
                    });

                    if (!result.success) {
                        console.error('Start exam failed:', result.message);
                        return;
                    }

                    state.examSession = {
                        sessionId: result.data.sessionId,
                        currentQuestion: result.data.currentQuestion
                    };
                    state.roundEndsAt = result.data.roundEndsAt;
                    state.tabSwitchCount = result.data.tabSwitchCount || 0;
                    state.currentQuestionNum = 1;

                    elements.roundBadge.textContent = `Round ${result.data.roundNumber}`;

                    // MNC STYLE: Load ALL questions at once (single API call)
                    await loadAllQuestions();

                    // Display first question
                    displayQuestion(1);
                    showScreen('exam');
                    startTimer();

                } catch (error) {
                    console.error('Start exam error:', error);
                }
            }

            // All questions stored in memory (MNC style)
            let allQuestions = [];

            // Load ALL questions at once (single API call)
            async function loadAllQuestions() {
                try {
                    const result = await api('/api/participant/all-questions');
                    if (result.success && result.data.questions) {
                        allQuestions = result.data.questions;
                    } else {
                        console.error('Failed to load questions:', result.message);
                        // Retry once after 1 second
                        await new Promise(r => setTimeout(r, 1000));
                        const retry = await api('/api/participant/all-questions');
                        if (retry.success && retry.data.questions) {
                            allQuestions = retry.data.questions;
                        }
                    }
                } catch (error) {
                    console.error('Load all questions error:', error);
                    // Retry once
                    try {
                        await new Promise(r => setTimeout(r, 1000));
                        const retry = await api('/api/participant/all-questions');
                        if (retry.success && retry.data.questions) {
                            allQuestions = retry.data.questions;
                        }
                    } catch (e) {
                        console.error('Retry also failed:', e);
                    }
                }
            }

            // Display question (INSTANT - no network call)
            function displayQuestion(questionNumber) {
                const question = allQuestions.find(q => q.questionNumber === questionNumber);
                if (!question) {
                    // Show error if questions not loaded
                    if (allQuestions.length === 0) {
                        elements.questionText.textContent = 'Failed to load questions. Please refresh the page.';
                    }
                    return;
                }

                state.currentQuestion = question;
                state.currentQuestionNum = questionNumber;

                // Restore previously selected answer if any
                state.selectedOption = state.answers[question.questionId] || null;

                // Update UI instantly
                elements.currentQuestionNum.textContent = questionNumber;
                elements.questionLabel.textContent = `Question ${questionNumber}`;
                elements.questionText.textContent = question.questionText;
                elements.progressFill.style.width = `${((questionNumber - 1) / 15) * 100}%`;
                elements.answeredCount.textContent = Object.keys(state.answers).length;

                // Update button text
                if (questionNumber >= 15) {
                    elements.nextBtnText.textContent = 'Submit Exam';
                } else {
                    elements.nextBtnText.textContent = 'Next Question';
                }

                // Render options
                renderOptions(question.options, state.selectedOption);
            }

            // For backward compatibility
            async function loadQuestion(questionNumber) {
                displayQuestion(questionNumber);
            }

            // Render options
            function renderOptions(options, selectedOption) {
                elements.optionsList.innerHTML = '';

                const optionKeys = ['A', 'B', 'C', 'D'];

                optionKeys.forEach(key => {
                    const optionItem = document.createElement('div');
                    optionItem.className = 'option-item';

                    const isChecked = selectedOption === key;

                    optionItem.innerHTML = `
                        <input 
                            type="radio" 
                            id="option${key}" 
                            name="answer" 
                            value="${key}" 
                            class="option-input"
                            ${isChecked ? 'checked' : ''}
                        >
                        <label for="option${key}" class="option-label">
                            <span class="option-indicator">${key}</span>
                            <span class="option-text">${options[key]}</span>
                        </label>
                    `;

                    const input = optionItem.querySelector('input');
                    input.addEventListener('change', () => {
                        state.selectedOption = key;
                    });

                    elements.optionsList.appendChild(optionItem);
                });
            }

            // Submit answer and go to next question (INSTANT - MNC STYLE)
            function submitAnswer() {
                if (state.isSubmitting) return;

                const currentNum = state.currentQuestionNum;
                const isLastQuestion = currentNum >= 15;
                const savedQuestionId = state.currentQuestion?.questionId;
                const savedOption = state.selectedOption;

                // Store answer in memory (no API call)
                if (savedQuestionId && savedOption) {
                    state.answers[savedQuestionId] = savedOption;
                }

                if (isLastQuestion) {
                    // Last question - submit ALL answers
                    state.isSubmitting = true;
                    elements.nextBtn.disabled = true;
                    submitExam('manual');
                } else {
                    // INSTANT: Display next question (pure DOM, no network)
                    displayQuestion(currentNum + 1);
                }
            }

            // Submit exam with ALL answers (BULK SUBMISSION)
            let submitRetryCount = 0;
            const MAX_SUBMIT_RETRIES = 3;

            async function submitExam(submissionType = 'manual') {
                if (state.isSubmitting && submissionType === 'manual') return;
                state.isSubmitting = true;
                elements.nextBtn.disabled = true;

                try {
                    // Convert answers object to array format for bulk insert
                    const answersArray = Object.entries(state.answers).map(([questionId, selectedOption]) => ({
                        question_id: questionId,
                        selected_option: selectedOption
                    }));

                    // SINGLE API CALL with ALL answers
                    const result = await api('/api/participant/submit-exam', {
                        method: 'POST',
                        body: JSON.stringify({
                            submissionType,
                            answers: answersArray  // All answers in one request
                        })
                    });

                    if (result.success) {
                        submitRetryCount = 0; // Reset on success
                        clearInterval(state.timerInterval);
                        showScreen('completion');

                        if (submissionType === 'auto_timer') {
                            elements.completionMessage.textContent =
                                'Time\'s up! Your answers have been automatically submitted.';
                        } else if (submissionType === 'auto_violation') {
                            elements.completionMessage.textContent =
                                'Due to policy violations, your exam has been submitted.';
                        } else {
                            elements.completionMessage.textContent =
                                'Your answers have been successfully submitted. Please wait for the results.';
                        }

                        elements.submissionTime.textContent = new Date().toLocaleTimeString();
                    } else {
                        throw new Error(result.message || 'Submission failed');
                    }

                } catch (error) {
                    console.error('Submit exam error:', error);
                    submitRetryCount++;

                    if (submitRetryCount < MAX_SUBMIT_RETRIES) {
                        // Retry with exponential backoff
                        setTimeout(() => submitExam(submissionType), 1000 * submitRetryCount);
                    } else {
                        // Max retries exceeded - show error
                        elements.completionMessage.textContent =
                            'Failed to submit exam. Please check your internet connection and refresh the page.';
                        showScreen('completion');
                    }
                } finally {
                    state.isSubmitting = false;
                }
            }

            // Handle tab switch/visibility change
            async function handleVisibilityChange() {
                if (document.hidden && screens.exam.classList.contains('active')) {
                    // Save current answer to state before reporting
                    if (state.currentQuestion?.questionId && state.selectedOption) {
                        state.answers[state.currentQuestion.questionId] = state.selectedOption;
                    }

                    // Tab switch during exam - send answers in case of auto-submit
                    try {
                        const answersArray = Object.entries(state.answers).map(([questionId, selectedOption]) => ({
                            question_id: questionId,
                            selected_option: selectedOption
                        }));

                        const result = await api('/api/participant/tab-switch', {
                            method: 'POST',
                            body: JSON.stringify({
                                violationType: 'visibility_change',
                                answers: answersArray  // Send answers for potential auto-submit
                            })
                        });

                        if (result.success) {
                            state.tabSwitchCount = result.data.tabSwitchCount;

                            if (result.data.autoSubmitted) {
                                // Exam was auto-submitted
                                clearInterval(state.timerInterval);
                                showScreen('completion');
                                elements.completionMessage.textContent =
                                    'Due to multiple tab switch violations, your exam has been automatically submitted.';
                                elements.submissionTime.textContent = new Date().toLocaleTimeString();
                            } else if (result.data.warning) {
                                // Show warning
                                elements.warningText.textContent =
                                    'You switched tabs or windows. This is your first warning. Another violation will result in automatic submission.';
                                elements.warningCount.textContent = `Violations: ${state.tabSwitchCount}/2`;
                                elements.warningOverlay.classList.remove('hidden');
                            }
                        }
                    } catch (error) {
                        console.error('Tab switch report error:', error);
                    }
                }
            }

            // Handle page refresh attempt
            function handleBeforeUnload(e) {
                if (screens.exam.classList.contains('active') && !state.isSubmitting) {
                    e.preventDefault();
                    e.returnValue = 'Your exam is in progress. Are you sure you want to leave?';
                    return e.returnValue;
                }
            }

            // Dismiss warning
            function dismissWarning() {
                elements.warningOverlay.classList.add('hidden');
            }

            // Initialize
            async function init() {
                await syncServerTime();
                await checkSession();
                startStatusPolling();

                // Event listeners
                elements.nextBtn.addEventListener('click', submitAnswer);
                elements.dismissWarning.addEventListener('click', dismissWarning);
                document.addEventListener('visibilitychange', handleVisibilityChange);
                window.addEventListener('beforeunload', handleBeforeUnload);

                // Prevent right-click context menu
                document.addEventListener('contextmenu', (e) => {
                    if (screens.exam.classList.contains('active')) {
                        e.preventDefault();
                    }
                });

                // Prevent keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (screens.exam.classList.contains('active')) {
                        // Prevent Ctrl+C, Ctrl+V, Ctrl+A, F12
                        if ((e.ctrlKey && ['c', 'v', 'a', 'u'].includes(e.key.toLowerCase())) ||
                            e.key === 'F12') {
                            e.preventDefault();
                        }
                    }
                });
            }

            init();
            init();
        })();
    </script>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        /**
         * Isometric Cyber Platform Animation
         * Based on user reference: Layered glass/tech platform in Blue/Cyan theme
         */
        (function () {
            const container = document.getElementById('canvas-container');
            const scene = new THREE.Scene();
            // Deep dark blue-black background
            scene.background = new THREE.Color(0x050a14);
            scene.fog = new THREE.FogExp2(0x050a14, 0.02);

            // Isometric Camera Setup
            const aspect = window.innerWidth / window.innerHeight;
            const d = 20;
            const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);

            // Isometric Angle
            camera.position.set(20, 20, 20);
            camera.lookAt(scene.position);

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // --- LIGHTING ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            const blueLight = new THREE.PointLight(0x0088ff, 2, 50);
            blueLight.position.set(-5, 10, -5);
            scene.add(blueLight);

            const cyanLight = new THREE.PointLight(0x00ffff, 1.5, 40);
            cyanLight.position.set(5, 5, 5);
            scene.add(cyanLight);

            // --- PLATFORM GROUP ---
            const platformGroup = new THREE.Group();
            scene.add(platformGroup);

            // Helper to create rounded box shape
            function createRoundedBoxShape(width, height, radius) {
                const shape = new THREE.Shape();
                const x = -width / 2;
                const y = -height / 2;

                shape.moveTo(x, y + radius);
                shape.lineTo(x, y + height - radius);
                shape.quadraticCurveTo(x, y + height, x + radius, y + height);
                shape.lineTo(x + width - radius, y + height);
                shape.quadraticCurveTo(x + width, y + height, x + width, y + height - radius);
                shape.lineTo(x + width, y + radius);
                shape.quadraticCurveTo(x + width, y, x + width - radius, y);
                shape.lineTo(x + radius, y);
                shape.quadraticCurveTo(x, y, x, y + radius);

                return shape;
            }

            // 1. Base Layer (The LED Matrix Block) - Using Blue/Cyan style
            // We use an ExtrudeGeometry for thickness
            const baseSize = 12;
            const baseShape = createRoundedBoxShape(baseSize, baseSize, 1);
            const baseGeometry = new THREE.ExtrudeGeometry(baseShape, {
                depth: 1.5,
                bevelEnabled: true,
                bevelSegments: 2,
                bevelSize: 0.1,
                bevelThickness: 0.1
            });
            // Rotate to lay flat
            baseGeometry.rotateX(Math.PI / 2);

            // Texture for LED matrix look
            const ledCanvas = document.createElement('canvas');
            ledCanvas.width = 128; // Increased resolution
            ledCanvas.height = 128;
            const ctx = ledCanvas.getContext('2d');
            ctx.fillStyle = '#001133';
            ctx.fillRect(0, 0, 128, 128);
            ctx.fillStyle = '#00ccff'; // Cyan dots

            // Create grid pattern
            for (let i = 0; i < 128; i += 8) {
                for (let j = 0; j < 128; j += 8) {
                    if ((i + j) % 16 === 0) { // Checkered/dotted pattern
                        ctx.beginPath();
                        ctx.arc(i + 4, j + 4, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            const ledTexture = new THREE.CanvasTexture(ledCanvas);
            ledTexture.wrapS = THREE.RepeatWrapping;
            ledTexture.wrapT = THREE.RepeatWrapping;
            ledTexture.minFilter = THREE.NearestFilter;
            ledTexture.magFilter = THREE.NearestFilter;

            // Emissive material for the sides to look like the glowing yellow block in reference, but BLUE
            const baseMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000,
                emissive: 0x0044aa, // Deep blue glow
                emissiveMap: ledTexture,
                emissiveIntensity: 2.0,
                roughness: 0.4,
                metalness: 0.8
            });
            // Top/Bottom faces can be darker
            const baseMesh = new THREE.Mesh(baseGeometry, [baseMaterial, baseMaterial]);
            baseMesh.position.y = -2;
            platformGroup.add(baseMesh);


            // 2. Middle Metallic Layer
            const midShape = createRoundedBoxShape(baseSize - 0.5, baseSize - 0.5, 0.8);
            const midGeometry = new THREE.ExtrudeGeometry(midShape, {
                depth: 0.5,
                bevelEnabled: true,
                bevelSize: 0.1,
                bevelThickness: 0.1
            });
            midGeometry.rotateX(Math.PI / 2);
            const midMaterial = new THREE.MeshStandardMaterial({
                color: 0x111111,
                roughness: 0.2,
                metalness: 0.9,
            });
            const midMesh = new THREE.Mesh(midGeometry, midMaterial);
            midMesh.position.y = -0.5;
            platformGroup.add(midMesh);

            // 3. Top Glass Layer
            const glassShape = createRoundedBoxShape(baseSize - 1, baseSize - 1, 0.6);
            const glassGeometry = new THREE.ExtrudeGeometry(glassShape, {
                depth: 0.2,
                bevelEnabled: true,
                bevelSize: 0.1,
                bevelThickness: 0.1
            });
            glassGeometry.rotateX(Math.PI / 2);
            const glassMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x000000,
                metalness: 0.1,
                roughness: 0.1,
                transmission: 0.9, // Glass-like transmission
                opacity: 0.8,
                transparent: true,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1
            });
            const glassMesh = new THREE.Mesh(glassGeometry, glassMaterial);
            glassMesh.position.y = 0.2;
            platformGroup.add(glassMesh);

            // 4. Glowing Border for Top Layer (Neon effect)
            const borderGeometry = new THREE.BufferGeometry();
            const borderPoints = [];
            // Create path points following the rounded rect shape roughly
            const w = (baseSize - 1) / 2;
            const r = 0.6;
            // Simplified border path
            const curve = new THREE.EllipseCurve(0, 0, w, w, 0, 2 * Math.PI, false, 0);
            // This is a circle, let's approximate the rounded square with points manually or shape.getPoints
            const shapePoints = glassShape.getPoints(50);
            const borderGeo = new THREE.BufferGeometry().setFromPoints(shapePoints);
            // Rotate to match
            borderGeo.rotateX(Math.PI / 2);
            const borderMat = new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 2 });
            const borderMesh = new THREE.LineLoop(borderGeo, borderMat);
            borderMesh.position.y = 0.42; // Just above glass
            platformGroup.add(borderMesh);


            // 5. Floating Elements (Icons/Particles)
            const particlesGroup = new THREE.Group();
            platformGroup.add(particlesGroup);

            const pGeo = new THREE.OctahedronGeometry(0.2);
            const pMat = new THREE.MeshBasicMaterial({ color: 0x00ccff });
            for (let i = 0; i < 15; i++) {
                const mesh = new THREE.Mesh(pGeo, pMat);
                mesh.position.set(
                    (Math.random() - 0.5) * 8,
                    2 + Math.random() * 4,
                    (Math.random() - 0.5) * 8
                );
                mesh.userData = {
                    speed: 0.02 + Math.random() * 0.02,
                    offset: Math.random() * Math.PI * 2
                };
                particlesGroup.add(mesh);
            }

            // 6. Central Hologram/Logo placeholder (Triangle/Cursor shape from reference)
            const cursorShape = new THREE.Shape();
            cursorShape.moveTo(0, 2);
            cursorShape.lineTo(1.5, -2);
            cursorShape.lineTo(0, -1);
            cursorShape.lineTo(-1.5, -2);
            cursorShape.lineTo(0, 2);

            const cursorGeo = new THREE.ExtrudeGeometry(cursorShape, { depth: 0.5, bevelEnabled: true, bevelSize: 0.1, bevelThickness: 0.1 });
            cursorGeo.rotateX(Math.PI / 2); // Make it stand up? No, float flat or tilted
            cursorGeo.rotateX(-Math.PI / 4); // Tilt up a bit

            const cursorMat = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                emissive: 0x00ffff,
                emissiveIntensity: 0.5,
                metalness: 0.8,
                roughness: 0.2
            });
            const cursorMesh = new THREE.Mesh(cursorGeo, cursorMat);
            cursorMesh.position.set(0, 1.5, 0);
            platformGroup.add(cursorMesh);

            // Animation Loop
            let time = 0;
            function animate() {
                requestAnimationFrame(animate);
                time += 0.02;

                // Gentle platform float
                platformGroup.position.y = Math.sin(time * 0.5) * 0.2;

                // Rotate particles
                particlesGroup.rotation.y = time * 0.2;
                particlesGroup.children.forEach(p => {
                    p.position.y += Math.sin(time + p.userData.offset) * 0.02;
                });

                // Animate cursor
                cursorMesh.rotation.y = Math.sin(time * 1.5) * 0.2;
                cursorMesh.position.y = 1.5 + Math.sin(time * 2) * 0.3;

                renderer.render(scene, camera);
            }

            // Resize Handler
            window.addEventListener('resize', () => {
                const aspect = window.innerWidth / window.innerHeight;
                camera.left = -d * aspect;
                camera.right = d * aspect;
                camera.top = d;
                camera.bottom = -d;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            animate();
        })();
    </script>
</body>

</html>